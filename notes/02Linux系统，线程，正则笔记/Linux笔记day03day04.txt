
python的常用命令：

#指定python路径  在代码里指定python解释器路径之后直接./a.py 就能执行
 注：查看路径可以输入 which python：
      python@ubuntu:~$ which python3
      #!/usr/bin/python3

1，python中程序的几种运行方式
  交互式：python   ipython（tab自动提示补齐）
         场景 -- 验证简单语法 

  执行：vim/sublime  + python解释器
      chmod +x *.py   ./a.py     （chmod +x *.py是为了让py文件可执行）
      另：ll在Ubuntu中是ls -l的缩写


打开多个终端：ctrl shift + T


（重点）
*** ctrl Z 是把程序切换到后台， 输入jobs 可以查看当前后台的程序，
         输入 fg空格1   fg空格2  可以切换要运行的后台（1,2是后台作业编号的意思）
*** ctrl D 是结束程序

*** ctrl C是干嘛的？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 
 

vim：
命令模式两个ZZ可以保存退出Vim

which python 查看python的位置（路径）


1，什么是网络？什么是网络编程？
 使用网络能够把多方链接在一起，然后可以进行数据传递
 网络编程：让在不同的电脑上的软件能够进行数据传递，即进 程之间的通信

2，什么是IP？

  ip地址：用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网  上是唯一的。
  IPV4--4个字节
  IPV6--8个字节
    

  A类IP地址
  一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最  高位必须是“0”，

  地址范围1.0.0.1-126.255.255.254
  
   B类IP地址范围 128.1.0.1-191.255.255.254
   
   C类IP地址
   3和1，地址范围：192.0.1.1 - 223.255.255.254
   
   D类地址多用于多点广播
   D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。

   E类IP地址
   以‘1111开始’，为将来保留使用，实验开发使用
   
   私有IP
    10.0.0.0～10.255.255.255

    172.16.0.0～172.31.255.255

    192.168.0.0～192.168.255.255 

    **IP地址127．0．0．1~127．255．255．255用于回路测试，
    * 127.0.0.1永远是本机地址
     

3，Linux 命令（ping ，ifconfig）
    
    ping 用于测试与目的IP地址的网络主机的网络是否通畅
     但是ping不通不一定代表网络不通，有可能是对方没答复
   查看或配置网卡信息：ifconfig
    ens33和lo是网卡名
    
    可以用root 权限修改ens33的IP地址
     sudo ifconfig ens33 192.168.1.108（重启之后会恢复初始值）

4，什么是端口？
   端口是：用来收发网络数据
   端口号：0-65536
   端口的作用：用以标示该系统中不同的进程
   
   端口的分配：
      知名端口：0-1023
          80端口分配给HTTP
           21端口分配给FTP
           22端口--ssh
          使用著名端口要root权限
            

      动态端口：1024-65536
            它一般不固定分配某种服务，而是动态分配
        动态分配是指当一个系统程序或应用程序程序需要网络通信时，       它向主机申请一个端口，主机从可用的端口号中分配一个供它使用       
    怎么样查看端口：
        用“netstat －an”查看端口状态
      sudo lsof -i :ssh   （知名端口）
      sudo lsof -i :22 查看占用22号端口的详情


5， 不同电脑上的进程如何通信？
    利用ip地址，协议，端口就可以标识网络的进程

    进程：运行的程序以及运行时用到的资源这个整体称之为进程

    进程间通信指的是：运行的程序之间的数据共享

6，什么是socket？ socket 原意：孔，插座；中文：套接字
     
    网络协议为什么要分层（意义）：
        封装--下层封装指定功能 上层直接使用
        隔离--下层变动的时候还是实现指定的功能，不影响其他层使用

    

   socket简称套接字，是进程通信的一种方式，他与其他进程通信的主要不同是：它能实现不同主机间的进程通信
   
   创建socket：
     import socket
     socket.socket(AddressFamily,Type)
       
      AddressFamily :可以选择 AF_INET(用于Internet进程间通信)或者            AF_UNIX（用于同一台机器进程间通信）,实际工作中常用           AF_INET
      Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于             TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP             协议）

 UDP创建 关闭
	
	import socket
	sock = socket.socket()方法创建一个套接字  返回的套接字对象

	sock.close() #关闭
  
        dest_addr = ('dest_ip', port)   注：目的ip  + 目的端口

	sock.sendto() # 发送   注括号里是data.encode(),dest_addr

   

    套接字使用流程 与 文件的使用流程很类似
      1.创建套接字
      2.使用套接字收/发数据
      3.关闭套接字

7，udp网络程序发送，接收数据（User Data Protocol）
  
代码如下： 
#coding=utf-8

from socket import *

# 1. 创建udp套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)

# 2. 准备接收方的地址
# '192.168.1.103'表示目的ip地址
# 8080表示目的端口
dest_addr = ('192.168.1.103', 8080)  # 注意 是元组，ip是字符串，端口是数字

# 3. 从键盘获取数据
send_data = input("请输入要发送的数据:")

# 4. 发送数据到指定的电脑上的指定程序中
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)

# 5. 关闭套接字
udp_socket.close()



8，python3编码转换
  
       安装网络助手：sudo  dpkg -i  安装包名
   
      在Linux中 系统默认编码都是utf-8；在windows中 是GBK
      如果在Linux中―》windows encode('GBK')
      如果在Linux中接收来自windows调试助手的数据 decode（GBK）

       python3中新增一个类型接收Bytes字节类型（二进制类型）

 格式： str->bytes:encode编码  字符串通过编码成为字节码
        bytes->str:decode解码  字节码通过解码成为字符串。

        str.encode()
           编码 之后， type(字符串)，此时是'bytes'类型
        bytes.decode()
           解码之后，type（字节码），此时是‘str’类型 

      其中decode()与encode()方法可以接受参数：
         bytes.decode(encoding="utf-8", errors="strict")
                       编码方案         错误的处理方案
         str.encode(encoding="utf-8", errors="strict")
          --》encoding指定编码时  使用的编码格式
	  --》在编码/解码 过程中如果出现 错误是使用严格模式还是忽略<了解>

演示：

	In [6]: data = "ahahahha哈哈哈"

	In [7]: data.encode()
	Out[7]: b'ahahahha\xe5\x93\x88\xe5\x93\x88\xe5\x93\x88'

	In [8]: b = data.encode()

	In [9]: b
	Out[9]: b'ahahahha\xe5\x93\x88\xe5\x93\x88\xe5\x93\x88'

	In [10]: b.decode()
	Out[10]: 'ahahahha哈哈哈'

8，发送数据
  
   套接字对象.sendto(data, 目的地址的元组（IP，端口）)

9，接收数据
   套接字对象.recvfrom（bufsize）接收数据 （1024的整数倍）
        如果没有数据会一直在这里阻塞等待
        bufsize标示最多能接收的数据大小
   返回值
        是一个元组（数据，源地址）
        源地址是一个元组  第一个元素是发送方的IP地址
        第二个元素是发送方的端口

        即 recvfrom（1024） 
           返回的是data，dest_addr=socket.recvfrom(1024)
            用print（'接受到来自%s的消息%s'%(dest_addr,data.decode() 来表达，但是接受到的data必须        要decode()解码，才能被读取到


10，udp绑定信息
  1.udp网络程序-端口问题
   
   没有确定用哪个端口，系统会随机分配
   网络程序在运行的过程中，端口就唯一标记这个程序，如果其他电脑上的网络程序要向此程序发送数据，那么就需要向这个数字（即端口）标识的程序发送即可
  

  2.udp绑定信息 bind
       
      函数作用  就是将一个本地地址与套接字进行关联
      --- 告诉操作系统我要用这个端口   你不要给我随机分配
   
     套接字对象.bind（本地地址）   即：socket.bind('',本地端口)
     本地地址是一个IP加端口的元组

     ip是‘’代表绑定本机所有的IP
     端口是数字
 



11，TCP协议 
    传输控制协议 Transmission Control Protocol
 
    创建连接、数据传送、终止连接

    这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的   应用程序请使用UDP协议

    TCP与UDP的不同点：
      面向连接（确认有创建三方交握，连接已创建才作传输。）
      有序数据传输
      重发丢失的数据包
      舍弃重复的数据包
      无差错的数据传输
      阻塞/流量控制


  TCP客户端

 1.构建客户端流程:

     import socket
    
    #创建socket
    tcp_client_socket = socket.scoekt(socket.AF_INET,socket.SOCK_STREAM)
 
    # 目的信息
    server_ip = input()
    server_port = input()
    
    # 链接服务器
    tcp_client_socket.connect((server_ip,server_port))
   
    # 提示用户输入数据
   send_data = input()
   
  tcp_client_socket.send(send_data.encode('gbk'))
  
   #接收对方发送过来的数据，最大字节1024
    recvData = tcp_client_socket.recv(1024)
     print('接收到的数据为：'，recvData.decode('gbk'))

   # 关闭套接字
    tcp_client_socket.close()
   

  2.TCP服务器流程;

    1.socket创建一个套接字
    2.bind绑定ip和port
    3.listen使套接字变为可以被动链接
    4.accept等待客户端的链接
    5.recv/send接收发送数据

   具体功能分析：
    tcp 发送/接收数据
     1. socket.send(bytes) # bytes 表示要发送的数据《bytes类型》，返回已成功发送的字节数
     2.socket.recv(bufsize)-->data  #bufsize 便是接收数据的最大长度，一般是2的整数次方大小，data在python3中是《bytes》类型
      
     3.绑定bind：(将套接字对象和地址（IP，端口）进行关联)
        socket_obj.bind(addr)  # addr是（IP，端口）组成的元组，客户端socket一般不需要绑定地址端口
                         
     4.监听listen：（将套接字设置为被动监听模式，使套接字可以accept接收用户的connect链接请求）
        listen（backlog）# backlog参数在不同os上含义不同，经验值是128

    5.接受accept：（功能：从套接字队列中取出一个客户）
         accept（）  # 返回值：（tcpsocket，(IP,端口)），python3中数据类型是bytes类型       
     注：6.bind失败问题
            原因:server 主动关闭进程（同时关闭tcp连接），导致tcp变为CLOSE_WAIT状态
                 2MSLX分钟内不能再bind该socket相关port
             
            解决方案：需要在listen调用之前设置
                      tcp_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,)   
  

   
服务器跟客户端是一一对应的：
     你编码的是客户端client，那么网络助手就要要设置为server


？？？什么是回射？

3，如果在网页 输入 http://127.0.0.1:8888可以访问你新建的服务器
   
   亲测：http://192.168.20.24:8080才可以访问你新建的服务器
   服务器需要绑定地址，客户端不需要


4，with语句
   
   1，自动捕获异常
   2，在with语句完成执行之后，可以自动释放file资源（即使内部有异常）


关于TCP的老师课堂笔记：

    1. 面向连接
	创建-使用-断开

	单播 1-1通信   TCP UDP
	多播 组播 - 1：多 UDP

    2. 主动断开连接的一方存在TIME_WAIT
	该TCP占有相关资源会保持x分钟 ---> 不能再使用
	2MSL 2倍 最大生命周期

	# 套接字选项 重用地址 设置(0表示取消设置)
	server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	设置该选项就可以不让操作系统保持该资源


     3. listen(backlog) 
	Linux
		backlog表示已经完成三次握手的 客户端套接字队列 长度
	其他
		未完成三次握手   + 已完成三次握手的总共长度
	accept()函数的作用就是已完成三次握手队列中取出一个套接字

5,TCP服务器和客户端问题

   下载文件客户端，下载文件服务器端：
      先运行服务器端，然后运行客户端，在同一路径下运行，注意，下载文件之后的文件名要改一下，不然无法保存下来，因为服务器也是在当前路径找的文件

  重点：
    1，tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器
    2，tcp客户端一般不绑定。因为是主动链接服务器，所以只需要确定好服务器的ip，port信息就好，本地客户端可以随机分配
    3，tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是tcp服务器必须要做的，
    4，档客户端需要连接服务器的时候，就需要使用connect进行连接，udp是不需要连接的而是直接发送，但是tcp必须先连接，只有连接成功才能通信
    5，当一个tcp客户端连接服务器的时候，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务
    6，listen后的套接字是被动套接字，用来接收新的客户端的链接请求，而accept返回的套接字是新套接字是标记这个客户端的
    7，关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前的已经链接成功的客户端会正常通信
    8，关闭accept返回的套接字意味着这个客户端已经服务完毕
    9，当客户端的套接字调用close后，服务器端会recv解开堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端客户端是否已经下线


 总结：

 UDP框架
    1，创建udp一个套接字完成发送和接收信息的功能;
      udp_socket=socket.socket.socket()--> dest_addr=('ip',port)-->data=input('')
     -->udp_socket.sendto(data.encode(),addr)-->recv_data,remote_addr =        udp_socket.recvfrom(1024)-->print()--> udp.socket.close()
    
      创建套接字》指定对方ip，端口》获取要输入的信息》发送信息》接收信息》关闭套接字
     注：udp套接字接收信息是用recvfrom（1024） bufsize是1024的倍数，接收的数据是data和remote_addr，remote_addr是目标的ip和port的元组，data要打印出来记得使用decode（）解码     
  2,创建一个udp套接字 实现回射消息
     udp_socket=socket()--udp_socket.bind(('',8888))--data,remote_addr = udp_socket.recvfrom(4096)--print()--udp_socket.sendto(data,remote_addr)--udp.socket.close（）
      
      创建套接字》绑定ip和端口》接收对方信息》发送刚刚接收到的信息》关闭套接字
  
  3，创建一个udp聊天系统（要求能获取两个功能：1，发送消息，2接收消息）
      def send_msg(udp_socket):
             data = input()
             ip = input()
             port = int(input())
             dest_addr = (ip,port)
                   
             udp_socket.sendto(data.encode(),dest_addr)
      
      def recv_msg(udp_socket):
             data,remote_addr = udp_socket.recvfrom(4096)
             print('接收到来自%s的信息%s'%（str(remote_addr),data.decode()）)

      if __name__ == '__main__':
             
           udp_socket = socket()
           udp_socket.bind(('',8888))
          
           while True:
               
               op = input('1.发数据 2.收数据：')
               if op == 1:
                   send_msg(udp.socket)
               elif op == 2:
                   recv_msg(udp_socket)  
                else:
                   print('输入错误')                  

          
 
TCP框架
       
    1，TCP客户端
    tcp_socket = socket()--> tcp_socket.connect(('192.168.32.1',8888)) --> data = input('') --> tcp_socket.send(data.encode()) --> recv_data = tcp_socket.recv(4096)
--> 打印if recv_data:print()  else:print（''）--> 关闭套接字
   
    创建TCP套接字》链接服务器》输入信息》发送信息》接收信息》打印接收到的信息》关闭

   2，TCP服务器
     tcp_socket = socket() --> tcp_socket.bind(('',8888)) --> tcp_socket.listen(128)
--> (while True) client_socket,client-addr = tcp_socket.accpt() -->print('收到来自%s的链接请求'% str(client_addr)) --> recv_data = client_socket.recv(4096) --> if recv_data: print('收到来自%s的数据%s'%(str(clietn_addr),recv_data.decode()))  ；client_socket.send(recv_data)  ;else: print('收到来自%s断开的请求'%str(client_addr))
--> client_socket.close()   ---->tcp_socket.close()
   
    创建tcp套接字》绑定本机地址》监听》
 


































