淘宝买个域名30-50元 如：baidu.com （域名可以对应ip地址）  

  单核cup执行程序调度算法：时间片轮转，优先级调度

1，多任务
    并发，任务数多于cpu核数，有的任务先执行
    并行，任务数小于等于cpu核数，任务一起执行


单线程：
    一次只执行一个


多线程：
   一次执行多个

threading 线程（ 车缧纹，攻[套]丝（扣），扣纹; 穿线; 穿板;）

  import threadimg 模块; (多线程)
    #coding=utf-8
    import threading
    import time

    def saySorry():
        print("亲爱的，我错了，我能吃饭了吗？")
        time.sleep(1)

    if __name__ == "__main__":
        for i in range(5):
             t = threading.Thread(target=saySorry)
             t.start() #启动线程，即让线程开始执行

*主线程会等待所有的子线程结束后才结束

*查看线程数量    ？？？？？？？？？？？？？？？？？？
    #coding=utf-8
    import threading
    from time import sleep,ctime

    def sing():
        for i in range(3):
            print("正在唱歌...%d"%i)
            sleep(1)

    def dance():
        for i in range(3):
            print("正在跳舞...%d"%i)
            sleep(1)

    if __name__ == '__main__':
        print('---开始---:%s'%ctime())

        t1 = threading.Thread(target=sing)
        t2 = threading.Thread(target=dance)

        t1.start()
        t2.start()

        while True:
            length = len(threading.enumerate())
            print('当前运行的线程数为：%d'%length)
            if length<=1:
                break

            sleep(0.5)



进程的创建fork：
     
    import os
      # 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以
    pid = os.fork()

    if pid == 0:
        print('哈哈1')
    else:
        print('哈哈2') 
    




2，

什么是进程？什么是线程？
*进程是一个程序，线程是程序上的代码？
程序
   编写完毕的代码，在没有运行的时候，称之为程序
进程
  正在运行着的代码，就成为进程

  进程，除了包含代码以外，还有需要运行的环境等，所以和程序是有区别的



new
飞鸽传书

    ipmsg是用来在局域网中基于udp/tcp的应用层通信协议，功能如下:

       收发消息
       收发文件
       收发文件夹
  协议格式：
      版本号:数据包编号:发送者姓名:发送者主机名:命令字:附加选项
    
      1:123456789:itcast-python:localhost:32:hello
 
   说明:

  1 版本号，一般为1，较高版本的飞秋则较为复杂
  123456789 数据包编号，主要用来标记这个数据包，一般不重复，所以可以使用time来得到一个
  itcast-python 电脑的用户名
  localhost 主机名
  32 发送消息的命令      （1是上线的命令，2是下线命令）
  hello 发送的消息内容


*线程的注意点：
     1.线程之间执行顺序是无序的 
     2.主线程会等待所有子线程任务完成以后程序再退出

  
记住这个代码：
   # 查看当前任务执行的线程
    print("sing:",threading.current_thread())
          查看当前任务执行线程的代码是:threading.current_thread()

   # 当前程序活动线程的列表
    print('1---当前程序活动线程的列表：', threading.enumerate())
        活动线程的列表代码：threading.enumerate()


   # 设置广播 并开启
    udp_client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST,True)
    


*接收数据模块

# 提取命令字里面的命令及命令选项
def handle_command_num(command_num):
    # 使用按位与 提取命令及命令选项
    # 本质： 就是2个二进制数据进行按位与
    # 把第一个十进制转成二进制然后把16进制转成二进制，然后使用二进制进行按位与
    command = int(command_num) & 0x000000ff
    # 提取命令选项
    command_option = int(command_num) & 0xffffff00
    return command, command_option




【群发消息】解决 recvfrom 时报错误：提供了一个无效的参数
第一种解决方式：在linux下运行，不在window上运行；
第二种解决方式：给socket绑定2425端口 socket.bind((“”,2425)) 
第三种解决方式：不能程序一启动就执行recvfrom，要么先发送上线消息，要么向某个IP发送消息 后，再recvfrom就可以了 



设置源根 -》mark directory as -》sources root  就是从当前目录查找模块





飞鸽传书 大体框架：





飞鸽传书代码优化：将相同的代码设置成一个函数，使用时调用即可，build_msg,send_msg,在上线，下线，发送消息的时候分别调用

模块化提取：将模块安装功能提取为Global，main，recv，send，并把对应函数分割进去


main：（为了让接收这一步在操作的时候不造成阻塞，单独创建一个子线程让接收单独运行）在 main主进程里创建套接字的后面用创建recv_thread,然后设置为守护主线程

recv:(处理接收到的数据)def handle_recv_data()，具体将recv_data里的数据按照“：，5”切分，然后创建一个空字典，将接收到消息的用户名和ip放进字典中

recv:(提取命令 和命令字进行按位与操作)def handle_command_num()

recv；（将上个步骤返回的command，进行判断Global.ENTRY,打印相关，接收信息）

main：（为了接收对方上线，下线消息）在创建套接字函数里 绑定端口-》

recv：（别人上线的时候，如果你在线，你的告诉人家，回复对方我也在线）即在recv主线里上线的地方下面添加一个send发送消息给上线的它，

global：（告知对方自己已经收到消息）添加全局变量 IPMSG_RECVMSG = 0x00000021

recv：（告知对方收到消息） 在recv里接收消息的地方下面，添加一个回复消息 send_content，        Global.send_msg()

send :（由于上面两个告知步骤的冗余，可以在send模块里专门设置两个函数来处理回复）分别是
       def send_answer_msg()  和 def send_tell_msg(),然后在Send模块里面的build_msg方法里把content参数设置为空即，content='',这样在send_tell_msg方法里就可以不用传参

global；（保存在线用户列表）在global里定义一个空列表online_user_list = list()

recv：（创建一个空字典将上线的以及在线ip和用户名的保存起来）在recv里comman==ENTRY 后面创一个空dict，online_user_dict = dict()

main:(添加一个功能使能够查看在线的用户名单) 在main的def show_menu()里加上print（‘4.查看在线信息’），同时在主进程上要添加上4选项

main： （查看在线用户列表实质上是遍历列表）创建遍历方法def show_online_user_list()
      用 enumerate遍历，并打印 （这时候会发现只要你上线一次，名单会增加一次，有重复的）

recv：(处理保存在线用户信息的逻辑才，判断在线的用户是否已经在列表中，如果在不添加，否则添加) 在recv 里面 append的地方，将此方法copy出去单独建立方法def handle_save_online_user_list(),遍历列表，判断username  and destip是否在列表中，在的话就break ，不在的话就添加； 同理把此方法在 command==ANSENTRY 后面也调用一次，因为在线的用户也要添加进去


recv：（删除下线用户信息，对方如果下线就不能再出现在列表中）在recv 里def remove_offline_user_info(destip), 遍历online_user_list,如果遍历出的current_user_dict['destip']==destip,就删除这个列表，根据ip删除下线用户， 在下线的地方EXIT调用此方法


send：（给指定用户发送消息）在send模块里导入main模块，然后设置给对方ip发送消息的方法 def send_msg_to_destip(),具体方法为 先显示在线用户列表：main.show_online_user_list(),
 ,然后输入index（input用户的序号），根据序号在在线列表里查找指定用户字典user_dict,然后 根据user_dict查找dest_ip,找这个dest_ip的目的是为了方便在发消息时直接根据这个ip传入后 面的代码发消息，为了防止输入的序号不在列表中，可以设置try...except...来捕获异常，然后 return e  返回异常信息描述，打印（‘输入不合法’） 打印（‘错误信息描述为：’），
  这里要注意缩进，因为你输入‘0’，了之后就进入显示列表，不能进直接发送消息的程序，注 ，完成此步骤之后，既可以输入‘0’，显示列表及序号，来选择对应序号的用户发送消息，也可 以根据 输入ip直接发送消息！！即两种方法都可行
  （此步的名称为优化 发送信息给指定用户！）



注意事项：
    1，如果encode（'gbk'）报错，那么就将其改为不那么严格 encode（'gbk',errors='ignore'） 
    2,设置源根 -》mark directory as -》sources root  就是从当前目录查找模块


 群发消息】解决 recvfrom 时报错误：提供了一个无效的参数
第一种解决方式：在linux下运行，不在window上运行；
第二种解决方式：给socket绑定2425端口 socket.bind((“”,2425)) 
第三种解决方式：不能程序一启动就执行recvfrom，要么先发送上线消息，要么向某个IP发送消息 后，再recvfrom就可以了 








































































