
  正则表达式;记录文本规则的代码

1.导入正则表达式模块：import re

 re使用过程:
 
   #1.导入模块
   import re
   # 2.使用match方法进行匹配操作
   res = re.match(正则表达式，要匹配的字符串)
   # 3.如果上一步匹配到数据的话，可以使用group方法来提取数据
   res.group()

  注：re.match()能够匹配出以xxx开头的字符串、


2.匹配单个字符：（仅限第一个！）

   ‘.’   匹配任意1个字符（除了\n 换行符） 
    [ ]	   匹配[ ]中列举的字符  # 即[0-9a-zA-Z_]
    \d	   匹配数字，即0-9     
    \D     匹配非数字，即不是数字  #(只要不是数字都可以匹配，例如￥)
    \s     匹配空白，即 空格，tab键
    \S     匹配非空白
    \w	   匹配单词字符，即a-z、A-Z、0-9、_  # 相当于[a-zA-Z0-9_]
    \W	   匹配非单词字符(匹配不是字母，数字的单词)      #  $ % ^&
     “.”
     ret = re.match(".","MBA")       
     print(ret.group())
     结果：M

     ret = re.match("t.o","two")
     print(ret.group())
     运行结果：two
     
     【】
     # 大小写h都可以的情况
     ret = re.match("[hH]","hello Python")
     print(ret.group()) --》 结果：h
      注：就算[]里写再多，也只能取到第一个符合的字符，但是大小写均可
     
     # 匹配0到9第二种写法
     ret = re.match("[0-9]Hello Python","7Hello Python")
     print(ret.group())
     结果：7Hello Python
    
       注：如果匹配不到 会报错
 
     \d
     
      # 普通的匹配方式
      ret = re.match("嫦娥1号","嫦娥1号发射成功") 
      print(ret.group())


      # 使用\d进行匹配
      ret = re.match("嫦娥\d号","嫦娥1号发射成功") 
      print(ret.group())
  
      注： .   \d  []  \s   \w   都仅仅是匹配一位，只不过适应的范围不同 


3.匹配多个字符  （注：我要求你有的 你必须要有，我没有要求的你可以没有可以有，才能匹配成功）
   匹配多个字符的相关格式  
   
    注：以下字符都是 用来修饰前一个数字或字符的 如：.* ，https+，haha{5}

 字符	功能
 *	匹配前一个字符出现0次或者无限次，即可有可无  #(修饰前面的一个符号或字符)
 +	匹配前一个字符出现1次或者无限次，即至少有1次  #(修饰前面的至少有一次)
 ?	匹配前一个字符出现1次或者0次，即要么有1次，要么没有
 {m}	匹配前一个字符出现m次        # {4} 表示4个字符
 {m,n}	匹配前一个字符出现从m到n次  #{4,20} 表示4-20个字符，记得是以逗号分隔
  {n,}  至少匹配n次， 
  
   ---*
   #  需求：匹配出，一个字符串第一个字母为大小字符，
   #      后面都是小写字母并且这些小写字母可有可无
     ret = re.match('[A-Z][a-z]*','Maaa11M')  # 加了个*号就很吊的样子
     print(ret.group())    ---> Maaa
   注：只要第一个字母是大写，后面的是小写字母，都可以匹配，小写字母可有可无
 
   *** +
  需求：匹配出，变量名是否有效
       names = ["name1","_name","2_name","__name__"]

      for name in names:
          ret = re.match("[a-zA-Z_]+[\w]*",name)
          if ret:
              print('变量名%s符合要求' % ret.group())
          else:
              print('变量名%s不合法' % name)
   *** ？
   需求：匹配出，0到99之间的数字
    ret = re.match('[1-9]?[0-9]*','1899522')
    print(ret.group())    #  这个格式就表示问号前面和后面的一定要有，其他的可有可无

   ***{m}
     # 题目1：匹配出163的邮箱地址，
     # 且@符号之前有4到20位，例如hello@163.com
     ret = re.match('[a-zA-Z0-9_]{4,20}@163.com','cdeA123_a@163.com')
     print(ret.group())


    # 匹配手机号码,    指定号段  ，结尾不要47 (不用[^47]是因为字母也是非47，用[0-35-                                                                68-9]能唯一确定是数字)
    ret = re.match('^1[34568]\d{8}[0-35-68-9]','13163752086')    
    print(ret.group())

匹配开头结尾

   字符	     功能
     ^	     匹配字符串开头    ##   [^47] 这个是除了4,7以外都匹配
     $	     匹配字符串结尾    
  
     #匹配以数字开头中间内容不管，以数字字母结尾
     ret = re.match('^\d.*[a-zA-Z]$','7_$W')
     print(ret.group())


4.匹配分组

  字符	  功能
  |	  匹配左右任意一个表达式
 (ab)	  将括号中字符作为一个分组
 \num	  引用分组num匹配到的字符串
 (?P<name>)	分组起别名
 (?P=name)	引用别名为name分组匹配到的字符串

  ***  |
    需求：匹配出0-100之间的数字
     
    # 添加 |  左右任意一个
    # ret = re.match('[1-9]?\d$|100','08')
    # print(ret.group())     # 左边没有

    ret = re.match('[1-9]?\d$|100','100')
    print(ret.group())    # 100

  *** （） |   匹配分组邮箱
    ret = re.match("\w{4,20}@(163|126|qq)\.com", "test@qq.com")
    print(ret.group())  # test@qq.com
 
    # 不是以4、7结尾的手机号码(11位) ###或者[^47] 这个是除了4,7以外都匹配
              # 是            不是         不是     不是
    tels = ['13100800123','18800000004','10010','110']
    for tel in tels:
        ret = re.match('1\d{9}[0-3,5-6,8-9]',tel)   #[0-3,5-6,8-9]表示最后一位不是4和7
        if ret:
            print(ret.group())
        else:
            print('%s不是想要的手机号码'% tel)
   
    # 提取区号和电话号码
    ret = re.match('([^-]*)-(\d+)','010-12345678')
    print(ret.group())    # 010-12345678

    # 匹配出<html>hh</html>
    # <h1>
    # \num 引用分组num匹配到的字符串,把前面的（html）用括号括起来
    #  算做第一个分组，在后面用\1 表示引用了分组1，多加一个\是为了转译/
    # 如果要不想转译/ ，可以在'表达式'前面加 ‘r’
    ret = re.match('<([0-9a-zA-Z]+)>.*</\\1>','<html>hh</html>')
    print(ret.group())   

   注：#获取分组数据，传入分组数，不是分组索引,注意：所谓的分组就是指（）小括号里的数                  据一个小括号是一个分组

5。提取网页数据（招聘职位要求）
  
    import re

     # 去找工作网站 找到相关职位信息，反键‘审查元素’，把对应区域的代码  copy element        ，到下面的desc
   desc = """<p>工作职责：<br>负责后端API开发<br><br>任职资格：<br>1. 计算机或相关专业           ，本科及已上学历；<br><br>2. 3年以上后端开发经验，熟悉mysql,redis,mongo,zk,           消息队列   ；<br><br>3. 有互联网企业后端开发经验；<br><br>4. 有GoLang或PHP           开发经验。</p>"""
  
   # 把<>中的内容全部替换为空
   ret = re.sub("</?[0-9a-zA-Z]+>","",desc)
   # 去除空格
   print(ret.strip())


6.贪婪与非贪婪
  
  import re
  img="""<img data-original="https://rpic.douyucdn.cn/acrpic/171102/652675_1823.jpg"          src="https://rpic.douyucdn.cn/acrpic/171102/652675_1823.jpg" style="display:          inline;">"""
   # 查找图片地址
   # python里面正则会默认是贪婪，尽量多的匹配img
   # 解决办法：使用非贪婪，尽量让前面少匹配数据，  使用？， ？在范围上    去使用，比如     ：*，+，{n,m},{n},{n,}
   # 提示： 如果获取的数据比预想结果数据要多，可以想到使用非贪婪方式加上？解决这个问题
   ret = re.search("http[s]?://.*?\.jpg",img)
   print(ret.group())


7.re高级模式
  
  # 查找指定数据 search
  ret = re.search('\d+',"苹果5个，梨子5个，总共10个")
  print(ret.group())      # 5

  # 查找多个，返回列表
  ret = re.findall('\d+',"苹果5个，梨子5个，总共10个")
  print(ret)   # ['5', '5', '10']


  # 替换
  # 参数1：正则   参数2：替换内容  参数3：要匹配的字符串
  ret = re.sub("\d+","200","葫芦娃：7个")
  print(ret)   # 葫芦娃：200个


  # 正则分隔
  mystr = "1:2,3.4"

  ret = re.split(':|,|\.',mystr)
  print(ret)    # ['1', '2', '3', '4']


  # 定义替换功能函数
  def show_msg(ret):
      res = ret.group()
      print(res)
      return "haha" + res   # 用 ("haha"+7）来替换 目标里面的数字

  ret = re.sub("\d+",show_msg,"葫芦娃：7个")
  print(ret)

8.r的使用

  # r: 表示原生字符串，反斜杠不需要再转义
  ret = re.match(r"c:\\a\\b\\c",mystr)
  if ret:
      print(ret.group())
  else:
      print("匹配失败")



上，


























































































      