1.下载文件流程

     1.1 判断接收的消息是文件消息还是普通消息
     1.2.如果是文件消息，保存文件的基本信息，比如：消息的包编号，文件的序号（请求下载文件的时候需要），文件名（写入文件二进制数据的时候需要），对方ip（建立tcp连接的时候需要），文件大小（判断是否文件下载完成）


     1.3 把下载文件的基本信息保存到下载文件的列表中
     1.4 根据文件序号选择下载某个文件，获取下载文件的字典信息
     1.5 使用同一消息队列完成进程间通信，需要封装文件的基本信息，把下载文件字典和发送文件字典  再使用一个字典封装
     1.6 在子进程判断获取的文件数据下载字典数据还是发送文件字典数据
     1.7 如果是下载文件的数据，根据下载的字典的信息创建tcp客户端socket，建立连接
     1.8 建立连接后，使用tcp socket发送下载文件的请求信息
     1.9 请求下载文件的信息发送完成后，接收对方给你发送的文件的二进制数据，完成文件的下载


  通俗的将整个流程:
     别人发文件消息给你，实际上是发给udp主进程上，判断为文件消息之后，主进程把文件消息以字典的形式，分装到文件消息队列queue里，但是由于文件消息队列也包含了发送文件的字典消息，为了区分，分别封装两个文件字典到两个字典里，一个类型为 发送文件消息字典，一个类型为下载文件消息字典；在tcp中共享queue消息队列，并且在tcp进程中判断字典类型，如果是下载字典类型，那么就用此类型里的字典信息创建tcp客户端socket，并且建立链接，然后使用tcp socket 发送下载文件的请求消息，下载文件的请求消息发送完成之后，接收对方给你发送的文件的二进制数据（以'wb'方式打开并写入接收的文件数据），完成文件的下载





# 发送文件
{'filename': 'main.py', 'fileindex': 0, 'packageid': 1509329724}


{
	type: “sendfile”,
	data: {'filename': 'main.py', 'fileindex': 0, 'packageid': 1509329724}
}




# 下载文件
{'filename': '2.txt', 'fileindex': 0, 'destip': '192.168.20.50', 'filesize': 18, 'packageid': 1509275250}

{
	type: “downloadfile”,
	data: {'filename': '2.txt', 'fileindex': 0, 'destip': '192.168.20.50', 'filesize': 18, 'packageid': 1509275250}
}



# 乌班图按照wireshark步骤

乌班图 wireshark安装步骤

sudo apt-get install wireshark

sudo gedit /usr/share/wireshark/init.lua
#注释倒数第二行，添加单行注释--
--dofile(DATA_DIR.."console.lua")






飞鸽传书接收文件流程：



1.Recv：（2097440: 0:1.py:010:59f59216:1: ）根据按位或判断接收到的消息是普通消息还是文件消息，如果是普通消息直接打印普通消息，如果是文件消息，需要取文件消息的‘content’部分，新建一个download_file_dict,把接收到的文件信息字典的包编号packagid保存进字典，find找到文件信息里content中“\0”的位置，根据“\0”以后的位置以“：”切分content，将对于的fileindex文件序号，filename文件名，filesize大小，destip发送请求的ip地址，依次保存到字典download_file_dict中，然后再把此字典append 添加进全局变量download_file_list中保存，以便对方下载的时候可以找到多个可下载的文件，如果不封装进去，每次只能发送一个文件消息，如果发送多个，后面的文件消息会覆盖之前的（注：在最开始为了方便查看接收到的信息，可以在handle_recv_data中  print(recv_content)）


2.Main：在主进程main中添加获取指令选项，show_download_file_list(显示要下载文件的列表)，即在测试此功能的时候多用飞秋发送几个文件给本地，然后按6，检测是否有多个文件信息以字典的形式在需要下载的列表中，注：其中需要下载的文件名字可能相同，但是文件的包编号是唯一的packageid，不需要去重


3.Main和Send：在main中添加指令选项，下载指定文件，在send模块中创建send_download_msg函数，函数里先调用Main中的show_download_file_list()函数（函数里遍历了要下载的文件列表，还有文件序号），显示要下载的文件列表信息，输入文件序号，打印选择的字典。注：创建好了之后记得在Main中调用


4.Send：在send中将获取的下载文件字典download_file_dict放入put   文件消息队列file_queue中，但此时在file_queue中有两种下载文件，一种是发送的下载文件，一种是要下载的下载文件，
这里的解决办法是，在最外层添加一个"type":"sendfile","type":"downloadfile"等键值对，分别封装成两个字典(封装发送文件的字典信息，封装下载文件的字典信息)，然后将两个字典put到file_queue中，在TCP中recv_queue_data（接收文件消息队列中的数据）函数中(这个函数意思是相当于共享udp主进程中的数据信息)，获取字典信息，判断条件，如果file_dict["type"] == "sendfile",将其保存到发送文件列表中，并打印，如果是file_dict["type"] == "downloadfile",打印file_dict["data"],此时的下载文件字典是download_file_dict = file_dict['data']


5.TCP:根据刚刚得到的下载文件字典，创建函数download_file(downloa_file_dict),下载指定文件，函数中要创建客户端套接字socket，创建连接，发送请求的下载文件基本信息，生成下载文件的请求信息，发送下载文件的请求信息，获取文件名，记录当前获取文件二进制数据的大小current_file_size = 0,   以二进制写模式打开刚刚获取的文件名，用while True循环写入数据，并记录文件大小（current_file_size）+= len(file_data),判断条件如果写入 数据的文件大小等于download_file_dict["filesize"]源文件的大小，那么就接收完成，跳出循环，用try...except将这段代码缩进，保证代码正常运行，关闭客户端套接字。测试下载功能7是否可以正常下载文件




注：
  1.如果出现下面报错：'list' object is not callable
   一定是在用下标取列表中元素的时候写的不是【】

2.以后上班，别人的数据不要改，要进行封装























































































































