

爱家租房




1.表

	------------------------------------------------------
	思想:

	多对多关系表的中间的表,跟其他表不一样

	'facility' secondary=house_facility

	在数据库中是有联合主键的:
		create table (
			id1 ...,
			id2 ...,
			Primary Key (id1,id2)
		)

	联合主键:在多对多情况中,1   1	 这样的对应关系一定是唯一的,如果不唯一说明存多了,这种一一对应的情况可以拿来当做主键
						  1   2	
                          2   2
                          3    1

    在这里添加记录是:
	    house1 = house(),facility1=facility()

	    house1.facilities = [facility1,house2]                      
	    db.session.add(house1)

		注: 没必要操作模型类,只需要操作两个相关联的模型类的属性,给它设值,就能 把第三张表的记录添加进去  

	------------------------------------------------------------
	操作:

	一.准备好模型类文件models.py置于ihome目录下,执行迁移操作:
		1.python main.py db init -->初始化迁移
		
		2.python main.py db migrate -m 'initial create table'
		注:此步如果直接执行会显示 没有变化,原因是代码没执行到models.py这个里面就已经结束了,所以需要将执行到的文件里面随便导入一个模型类让
		 执行过程会进去看一看,能找到这个表的模型类,这里我们将users.py里导入这个模型类:from ihome.models import User

		3.python main.py db upgrade 

		查看数据库:ihome 表


	二.在iHome目录下新建文件web_page.py 定义视图函数,返回静态html资源文件	

			@html.route('/<re(r".*"):file_name>')
			def get_html_file(file_name):
			    """提供静态html文件资源"""
			    # 从请求的路径中提取html文件名
			    # 去html目录中找到文件并返回给用户

			    if not file_name:
			        file_name = "index.html"

			    if file_name !="favicon.ico":

			        file_name = "html/" + file_name

			    # send_static_file ,函数会自动去静态目录中找文件返回包含文件内容的响应信息
			    resp = make_response(current_app.send_static_file(file_name))

			    # 生成csrf_token随机字符串
			    csrf_token = csrf.generate_csrf()

			    # 设置csrf用到的cookie
			    resp.set_cookie("csrf_token",csrf_token)

			    return resp

		    注:send_static_file() ,函数会自动去静态目录中找文件返回包含文件内容的响应信息


	三.在utils(自定义的方法都放在这个目录下)目录下新建commons.py用于自定义转换器 		    

				from werkzeug.routing import BaseConverter


				class ReConverter(BaseConverter):
				    """自定义正则转换器"""
				    def __init__(self,url_map,regex):
				        super(ReConverter,self).__init__(url_map)
				        self.regex = regex

	四.在iHome目录下新建文件__init__.py文件中注册蓝图的上面,注册刚刚自定义的转换器	        
		 	    1.# 注册自定义转换器
    			app.url_map.converters['re'] = ReConverter

			   2.# 注册静态页面蓝图
			    from ihome import web_page
			    app.register_blueprint(web_page.html)

    五.	访问页面:

		http://127.0.0.1:5000/register.html

		http://127.0.0.1:5000/index.html



	六. (web_page.py)浏览器自动发送的请求， GET 127.0.0.1:5000/favicon.ico    #网页的logo(所有网站都有)	

			如果请求的是favicon.ico 那么请求地址不需要拼接:

		   if file_name !="favicon.ico":
		        file_name = "html/" + file_name



	七.(web_page.py)	设置防护:

		    # send_static_file ,函数会自动去静态目录中找文件返回包含文件内容的响应信息
		    resp = make_response(current_app.send_static_file(file_name))

            # 生成csrf_token随机字符串
		    csrf_token = csrf.generate_csrf()

		    # 设置csrf用到的cookie
		    resp.set_cookie("csrf_token",csrf_token)  # 不设置有效期,关闭浏览器即失效

		问:为什么要在这里弄一个csrf防护? 
		答:1.因为在前后端分离的情况下,后端要处理csrf,但是不知道什么时候要处理,那么就在浏览器向后端发送请求
			的同时发送这样就比较方便,以后就不需要专门来生成csrf,这里把csrf放进响应体的对象的cookie里
			2.make_response()方法返回的是响应体的对象
			3.此时弄好之后刷新下页面,即可看到,生成的csrf_token随机字符串

	-----------------------------------------------------
		1.开启csrf防护机制:
			从cookie中读取csrf_token 的值,从请求体中读取csrf_token的值
			对两个值进行比较,如果相同,允许访问
						    如果不同,返回403错误
			注:前后端分离需要注意csrf_token的发起和接收				    

		2.csrf-->跨站请求伪造攻击;

		黑客利用 用户来攻击:
			用户-->浏览器-->银行cookie-->hack页面-->点我(图片)-->
			带着cookie-->发起请求-->银行-->达到目的

		防护:csrf_token

		同源策略:不同的网站不能互相操作资源

		注:抓包 与csrf攻击不一样

	------------------------------------------------------
	八.验证码:

		代码如下:

		from . import api
		from ihome.utils.captcha.captcha import captcha
		from ihome import redis_store,constants
		from flask import current_app,jsonify
		from ihome.utils.response_code import RET


		# GET  /image_codes/图片验证码编号
		@api.route('/image_codes/<image_code_id>')   # 之前已经自定义了转换器，可以过滤字符串
		def get_image_code(image_code_id):
		    """提供图片验证码"""
		    # 提取参数， image_code_id 编号
		    # 生成验证码图片
		    # 名字  验证码真实值   验证码图片
		  
		    name,text,image_data = captcha.generate_captcha()


		    #保存验证码的真实值和这个验证码的编号，redis中，可以用到有效期
		    # redis数据类型：字符串，列表，hash，set。。。
		    # key：val
		    # “image_code_编号1”：“真实值”
		    # “image_code_编号2”：“真实值”

		    # redis_store.set(key,val)
		    # redis_store.set("image_code_%s" % image_code_id,text)
		    # redis_store.expire("image_code_%s" % image_code_id,constants.IMAGE_CODE_REDIS_EXPIRES)
		    try:                                    # 验证码id          过期时间                       真实值
		        redis_store.setex("image_code_%s" % image_code_id,constants.IMAGE_CODE_REDIS_EXPIRES,text)
		    except Exception as e:
		        current_app.logger.error(e)
		        return jsonify(errcode=RET.DBERR,errmsg="数据库异常")

		    # 返回验证码图片（自己定义响应头）
		    return image_data,200,{"Content-Type":"image/jpg"}

		注:
		1.每条验证码都用一条记录来保存，可以用字符串来保存在redis中,保存的格式是:验证码id:验证码真实值 这样的键值对(image_code_123:2B3C)
		2.setex（）方法封装了，设置redis中字符串，以及设置其有效期的这样一个函数
		3.业务逻辑的方法放在ihome目录下的constants.py文件中
		4.图片验证码在redis中保存的有效期  ，单位：秒
			IMAGE_CODE_REDIS_EXPIRES = 300-->此代码写在ihome目录下方的constants.py文件中,当做全局文件来用
		5.为了防止在写入redis数据的过程出错，用try捕获异常,并且返回RET错误信息

		


		要在api_v1_0目录下user.py 文件中导入,让其执行过程中能找到这个视图函数,佛则执行访问的时候,无法找到视图函数而保持 URL NotFound
		from . import houses,orders,users,verify_code

		访问:127.0.0.1:5000/api/v1.0/image_codes/123  # 数字任意
			可以查看到验证码图片,并且此时去redis中查看keys * ,可以看到 "image_code_123",查看其对应的值:get image_code_123---> 验证码真实值
			这个值跟验证码图片上的值一毛一样


		注:flask中,在哪个模块中就用什么来装饰视图函数,如在主模块一般用app来装饰,那是因为定义了 app=Flask(__name__),
			在不同的蓝图中,就用定义的蓝图名来装饰蓝图里的函数,如: api = Blueprint('api',__name__),那么这个蓝图中的视图函数都要用
			@app.route()这种来装饰,
		'

  		----------------------------------------------------------------
		1.验证码:

			图片验证码的流程:(业务逻辑)
			用户-->获取验证码-->flask生成验证码-->返回给用户-->顺便保存验证码编号到redis中-->用户短信验证-->后端接收短信-->从redis中调编号对比验证-->正确通过或者不正确重新验证
		
			注:1.flask内部生成验证码的流程:生成验证码图片,生成验证码编号,保存验证码的真实值和这个验证码的编号(redis中)

				2.业务逻辑没有low不low之分,有任何含糊的地方一定要问清楚
				不然,开发完了,发现逻辑错了,又得重新来!!
		---------------------------------------------------------		
	
	九:前端代码编写:
	
		前端思路:在前端页面一加载的过程中就需要将验证码图片返回展现给用户,那么就需要
				用到ajax请求,在前端页面的代码中,img 标签(验证码的地方)的地方,将图片的地址链接放在这里,然后浏览器在
				执行代码的过程中检查到了这个地址就会自动向后端发起请求,来请求验证码视图,

			
			------------------------------------------------
			代码如下:
				在前端register.js文件中:
			// 生成一个图片验证码的编号，并设置页面中图片验证码img标签的src属性
			function generateImageCode() {
			    // 生成一个编号
			    // 严格一点的使用uuid保证编号唯一， 不是很严谨的情况下，也可以使用时间戳
			    var imageCodeId = generateUUID();

			    // 设置页面中图片验证码img标签的src属性(拼接验证码图片的路径，请求路径)
			    var url = "/api/v1.0/image_codes/" + imageCodeId;
			    //  设置到前端页面中
			    $(".image-code img").attr("src", url);
			}


			访问:127.0.0.1:5000/register.html
				
				redis:回过头访问redis,查看keys *,可以看到刚刚生成的image_code_uuid
					-->image_code_1cb940d8-6949-4b10-8e53-11d00889824b

			注:由于之前设置的redis保存时间为3分钟,所以之前保存的数据会过期消失		
		------------------------------------------------------------------------
		UUID  :通用唯一识别码(universal unique identifier),由32个16进制数字构成
				16的32次方

		--------------------------------------------------
		2.RESTful风格
			后端就是用来表现数据的

			1.域名
				goods

				不符合风格:
				/get_goods 查
				/save_goods  保存
				/update_goods  更新
				/delete_goods  删除

				符合风格:
				/goods  路径中只出名词(不再出现动词),表示操作的数据资源


				使用HTTP的不同的请求方式来对应增删改查四种操作:

				GET /goods 查询商品数据
				POST  /goods  保存一个商品数据
				PUT  /goods  修改商品的数据
				DELETE /goods  删除商品的数据

				示例:	
				将api部署在专用域名下：

				http://api.example.com
				或者将api放在主域名下：

				http://www.example.com/api/

			2.版本
				将API的版本号放在url中。

				http://www.example.com/app/1.0/info
				http://www.example.com/app/1.2/info

			3、路径：
				路径表示API的具体网址。每个网址代表一种资源。 资源作为网址，网址中不能有动词只能有名词，一般名词要与数据库的表名对应。而且名词要使用复数。

				正确示例：

				#获取单个商品
				http://www.example.com/app/goods/1
				#获取所有商品
				http://www.example.com/app/goods

			4、使用标准的HTTP方法：
				对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有四个。

				GET     SELECT ：从服务器获取资源。
				POST    CREATE ：在服务器新建资源。
				PUT     UPDATE ：在服务器更新资源。
				DELETE  DELETE ：从服务器删除资源。

				#获取指定商品的信息
				GET http://www.example.com/goods/ID
				#新建商品的信息
				POST http://www.example.com/goods
				#更新指定商品的信息
				PUT http://www.example.com/goods/ID
				#删除指定商品的信息
				DELETE http://www.example.com/goods/ID

		   5、过滤信息：
				如果资源数据较多，服务器不能将所有数据一次全部返回给客户端。API应该提供参数，过滤返回结果。 实例：

				#指定返回数据的数量
				http://www.example.com/goods?limit=10
				#指定返回数据的开始位置
				http://www.example.com/goods?offset=10
				#指定第几页，以及每页数据的数量
				http://www.example.com/goods?page=2&per_page=20


			6、状态码：
				服务器向用户返回的状态码和提示信息，常用的有：

				200 OK  ：服务器成功返回用户请求的数据
				201 CREATED ：用户新建或修改数据成功。
				202 Accepted：表示请求已进入后台排队。
				400 INVALID REQUEST ：用户发出的请求有错误。
				401 Unauthorized ：用户没有权限。
				403 Forbidden ：访问被禁止。
				404 NOT FOUND ：请求针对的是不存在的记录。
				406 Not Acceptable ：用户请求的的格式不正确。
				500 INTERNAL SERVER ERROR ：服务器发生错误。

				注:在微信中又是一种风格,它是不管你是哪种情况都返回 200 状态码
					具体数据用jsonify()来返回


			7.错误信息		

				一般来说，服务器返回的错误信息，以键值对的形式返回。

				{
				    error:'Invalid API KEY'
				}


			8、响应结果：
				针对不同结果，服务器向客户端返回的结果应符合以下规范。

				#返回商品列表
				GET    http://www.example.com/goods
				#返回单个商品
				GET    http://www.example.com/goods/cup
				#返回新生成的商品
				POST   http://www.example.com/goods
				#返回一个空文档
				DELETE http://www.example.com/goods

			9、使用链接关联相关的资源：
				在返回响应结果时提供链接其他API的方法，使客户端很方便的获取相关联的信息。

			10、其他：
				服务器返回的数据格式，应该尽量使用JSON，避免使用XML。





























































































































