

爱家租房


1.用户实名认证代码的实现:
	后端:
	1.1user.py和passport.py:	

		@api.route('/user/name',methods=["PUT"]) # 注意原先已经有过数据，修改要用PUT请求方式
		@login_required
		def change_user_name()
			"""修改用户名"""
			pass

		@api.route('/user',methods=["GET"])
		@login_required
		def get_user_profile()
			"""获取个人信息"""
			pass

		# 这个方法跟上面一样，只不过返回值不一样，一个to-dict，一个auth-to-dict
		@api.route('/user/auth',methods=["GET"])
		@login_required
		def get_user_auth()
			"""获取用户的实名认证信息"""
			pass

		@api.route('/user/auth',methods=["POST"])
		@login_required
		def set_user_auth()
			"""设置用户名"""
			pass


	1.2models.py中的 class User():	
		添加如下两个方法用于,将要返回的数据转化为字典

	    def to_dict(self):
        """将对象转换为字典数据"""


	    def auth_to_dict(self):
	        """将实名信息转换为字典数据"""


	前端:	
	1.3profile.js 
		$.ajax({

			})

	1.4	auth.js

	1.5





2.我的房源-->发布房源信息
	实际开发的时候返回错误信息的时候要用英文!
	


	---------------------------------------------------------
	操作:
		2.1后端:

		2.1.1获取城区信息:
		@api.route('/area_info',methods=['GET'])
		def get_area_info():
		    """获取城区信息"""
		     1.先尝试读取缓存，如果有就直接返回(resp_json_str = redis_store.get("area_info"))resp_json_str = redis_store.get("area_info")
		     返回缓存的数据格式需要拼接响应头(return resp_json_str, 200, {"Content-Type": "application/json"})

		     2.如果没有缓存 --> 查询数据库(areas = Area.query.all())-->返回的是对象的列表

		     3.遍历对象列表,取出对象,调用在Area模型类中自定义方法to_dict(),转换格式为字典,添加到空列表中(areas_dict_li.append(area.to_dict())    # [{}, {} , {}]

		     4.封装成一个大的字典,(    resp_dict = dict(errcode=RET.OK,errmsg="查询成功",data={"areas":areas_dict_li}))	

		     5.转成json字符串 (resp_json_str = json.dumps(resp_dict)  # '[{"aid":1,"aname":"xx",{}},{}]'
		     6.保存在redis中,并且设置有效期setex()	
		     7.返回数据 ,并拼接响应头,指明json格式(  return resp_json_str,200,{"Content-Type":"application/json"} # 自己拼接响应头，不用jsonify去完成，jsonify性能没这个快)


		2.1.2保存房屋信息:   
		@api.route("/houses/info",methods=['POST'])
		@login_required
		def save_house_info():
		    """保存房屋信息"""

	        # 前端发送过来的json数据
		    # {
		    #     "title":"",
		    #     "price":"",
		    #     "area_id":"1",
		    #     "address":"",
		    #     "room_count":"",
		    #     "acreage":"",
		    #     "unit":"",
		    #     "capacity":"",
		    #     "beds":"",
		    #     "deposit":"",
		    #     "min_days":"",
		    #     "max_days":"",
		    #     "facility":["7","8"]   # 这个字段在下面没有用到，时因为用户可以不勾选设备
		    # }
		    # """
		    1.获取参数(根据上面传过来的获取必传的,注:facility设施不是必传的,可以后面处理)
		    2.校验参数
		    3.判断城区id
		    4.处理金钱数据(200.99)
		    5.保存数据到数据库中（创建对象，将参数传进去，这些时必传的）
		    6.处理房屋的配套设施:
		    ...
	        if facility_obj_list:
	            # 表示用户勾选了有效的设施
	            # 保存房屋的设施信息，注意：这是sqlalchemy中多对多关系数据的保存处理方式--》
	            # 先创建对象，将对象的相关属性，设置为对应表对象的列表 
	            house.facilities = facility_obj_list
	        ...
	        7.保存房屋信息到数据库:
                db.session.add(house)
   				db.session.commit()
            8.返回, 因为后面要用到house_id ,所以用data={} 返回user——id 给前端
    		return jsonify(errcode=RET.OK,errmsg="保存成功",data={"house_id":house.id})

    		注:保存房屋图片的时候,可以业务细化,如上传好几张图片,将某一张作为房屋展示的主图片


    	2.1.3保存房屋的图片:
		@api.route('/houses/images',methods=['POST'])
		@login_required
		def save_house_image():
		    """保存房屋的图片"""

		    1.获取参数,图片和house_id
		    2.校验参数
		    3.校验house_id是否是合理值,房屋是否存在
		    4.上传图片(这里要调用自定义的七牛上传图片的接口函数)()
				image_data = image_file.read()
    			file_name = storage_image(image_data)
    		5.保存在数据库 (创建房屋图片对象)	
			    house_image = HouseImage(
			        house_id=house_id,
			        url=file_name
			    )
		        db.session.add(house_image)
			6.处理房屋的主要图片(作为展示房屋的图片,以后可以技术细化,如上传好几张图片,然后)    
			7.返回拼接后的数据(注:image_url=constants.QINIU_URL_DOMIAN + file_name)
			    return jsonify(errcode=RET.OK,errmsg="保存成功",data={"image_url":image_url})

	
		2.1.4获取房东发布的房源信息条目	    
		@api.route('/user/houses',methods=["GET"])
		@login_required
		def get_user_houses():
		    """获取房东发布的房源信息条目"""
		    1.查询数据
	        user = User.query.get(user_id)
	        houses = user.houses  # 通过外键
	        2.将查询到的房屋信息转换为字典存放到列表中(遍历,append)
	        3.返回列表


	    2.1.5获取主页幻灯片展示的房屋基本信息
        @api.route('/houses/index',methods=["GET"])
		def get_house_index(): 

			1.从缓存中尝试获取数据,如果获取失败就将ret=None( ret = redis_store.get("home_page_data"))
			2.如果ret有值,因为redis中保存的是json字符串，所以直接进行字符串拼接返回
			3.查询数据库,将访问订单数目最多的5条数据返回
			            houses = House.query.order_by(House.order_count.desc()).limit(constants.HOME_PAGE_MAX_HOUSES)
			4.筛选房屋(houses_list=[])-->如果房屋未设置主图片，则跳过,否则添加到列表(if not house.index_image_url:continue)           

			5.将数据转换为json,并保存到redis缓存中(dumps(),setex())
			6.拼接响应头返回(  return '{"errcode":0,"errmsg":"OK","data":%s}' % json_houses,200,{"Content-Type":"application/json"})


		2.1.6获取房屋详情:
		@api.route('/houses/<int:house_id>',methods=['GET'])  # 注意这里是选择器
		def get_house_detail(house_id):
		    """获取房屋详情"""
		    # 前端在房屋详情页面展示时，如果浏览页面的用户不是该房屋的房东，则展示预定按钮，否则不展示
		    # 所以需要后端返回登陆用户的user_id
		    # 尝试获取用户登陆的信息，若登陆，则返回给前端登陆用户的user_id,否则返回user_id =-1
	        user_id = session.get("user_id","-1")

	        1.校验参数
	        2.先从redis缓存中获取信息(ret = redis_store.get("house_info_%s" % house_id))
	        3.如果获取到,就拼接返回数据
		       resp_json_str = '{"errcode":"0","errmsg":"OK","data":{"user_id":%s,"house":%s}}' % (user_id,ret)
		       return resp_json_str,200,{"Content-Type": "application/json"}
		    4.查询数据库:(      house = House.query.get(house_id))
		    	   
		    5.将房屋对象转换为字典(要使用House模型类中自定义的转换字典的方法)
		    	        house_data = house.to_full_dict()

		    6.转换为json字符串格式,存入到redis中(dumps,setex)
		    7.返回数据:
		        resp = '{"errcode":"0", "errmsg":"OK", "data":{"user_id":%s, "house":%s}}' % (user_id, json_house)
			    return resp, 200, {"Content-Type":"application/json"}

	        
		2.1.7房屋的列表页数据:
		# GET /houses?sd=2018-01-01&ed=201801-11&aid=1&sk=new&p=1
		@api.route('/houses',methods=['GET'])
		def get_house_list():
		    """房屋的列表页数据
		    参数：期望查询的起始时间sd，结束时间ed，城区aid，排序sk，分页页数p
		    """	    
		    1.获取参数(上面那些参数,用request.args.get()获取)
		    2.校验参数
	        # 如果传递了参数
			# 判断日期格式是否正确
	        if start_date_str:
	            # datetime.strptime() # 字符串--》datetime 类型
	            # datetime.strftime() # datetime -->字符串 类型
	            # datetime.strftime("要转换的时间字符串",格式说明)
	            # datetime.strptime("2018-01-01 23:08:08","")
	            start_date = datetime.strptime(start_date_str,"%Y-%m-%d")  # 转换失败，抛出异常
	        if end_date_str:
	            end_date = datetime.strptime(end_date_str,"%Y-%m-%d") # 失败抛出异常

	        if start_date and end_date:
	            assert start_date <= end_date

	        3.判断城区
            # 判断城区
		    if area_id:
		        try:
		            area = Area.query.get(area_id)

		    4.判断页数
		    5.根据条件筛选房屋信息,数据库查询 
		        因为在二次搜索页面，时间，城区，排序等  这些参数不确定哪个会被用户选择，选择了之后才会传递到后端
			    那么我们就弄个空列表来装传递进来的参数,不然的话就得枚举所有的情况判断并处理
			    filter_params = [] 
			 -----------------------------------------------------   
			 知识点:
			    # 如果传递了城区参数
			    if area_id:
			        filter_params.append(House.area_id == area_id)   # 双等号“==” 表达式搜索条件append

			    注:append()添加一个表达式,返回的是 True 或者 False    




			 ----------------------------------------------------------
		    6.如果传递了城区参数

		        # 如果传递了时间参数
			    # 思路一  错误  (查询不冲突的房屋)
			    # 在订单表中查询(根据订单来查询)
			    # 与用户想要租的时间，不冲突，的订单房屋都有那些
			    # bug ：会遗漏那些没有被下过订单的房屋

			    # 思路二： 正确
			    在订单表中查询   (查询冲突的)
			     与用户想要主的时间 冲突 的订单房屋都有那些 ，也就是不能预定的
			     然后在房屋表中 查询排除冲突之后的剩下的房屋 （不会再遗漏那些没有被下过订单的房屋）
			    # conflict_house_obj_list = Order.query.filter(冲突条件).all()

			    冲突的条件， 比较是否有时间交集，如果有，表示冲突
			    # Order.begin_date Order.end_date  start_date用户预期的起始时间 end_date用户预期的结束时间
			    重要思路,不懂可以画图: Order.begin_date <= end_date and Order.end_date >= start_date

			    # conflict_house_id_list = [house_obj.id for house_obj in conflict_house_obj_list]
			    # 然后在房屋表中 查询排除冲突之后的剩下的房屋 （不会再遗漏那些没有被下过订单的房屋）
			    # select * from ih_house_info where id not in (冲突的房屋id)
			     House.query.filter(House.id.notin_(conflict_house_id_list))    
			    
			      注: 查询冲突添加的房屋id(House.id),然后 用 notin_() 方法排除冲突的查询集,那么剩下的就是不冲突的呢1

			7.如果传递了时间参数 (寻找冲突条件)   
			    # 如果传递了时间参数
			    # 如果传递了时间参数（对于时间有三种情况：起-束，起，束）
			    conflict_house_order_obj_list = None
			    try:
			        if start_date and end_date:
			            # 冲突的房屋定单,这个时根据房屋的订单来查询的，所以应该订单对象
			            # conflict_house_obj_list = Order.query.filter(Order.begin_date <= end_date, Order.end_date >= start_date ).all()
			            conflict_house_order_obj_list = Order.query.filter(Order.begin_date <= end_date, Order.end_date >= start_date ).all()

			        elif start_date:
			            # 冲突的房屋订单
			            # conflict_house_obj_list = Order.query.filter(Order.end_date >= start_date).all()
			            conflict_house_order_obj_list = Order.query.filter(Order.end_date >= start_date).all()

			        elif end_date:
			            # 冲突的房屋订单
			            # conflict_house_obj_list = Order.query.filter(Order.begin_date <= end_date).all()
			            conflict_house_order_obj_list = Order.query.filter(Order.begin_date <= end_date).all()

			    except Exception as e:
			        current_app.logger.error(e)
			        return jsonify(errcode=RET.DBERR,errmsg="数据库异常")

			    if conflict_house_order_obj_list:

			        # 表示有冲突的房屋
			        # 冲突房屋的id （列表生成器）
			        # conflict_house_id_list = [house_obj.id for house_obj in conflict_house_obj_list]  # id 是Order
			        conflict_house_id_list = [order_obj.house_id for order_obj in conflict_house_order_obj_list]  # 通过house_id 外键拿到house对象
			        # 向查询条件中添加过滤不冲突的房屋的添加

			        filter_params.append(House.id.notin_(conflict_house_id_list))

	重点理解()-->创建查询对象（查询：对象.query.filter(条件).all(), 只有加了最后一个查询方法（如all(),get(),first()）才算是对数据库进行了操作）
			  	query = House.query.filter(*filter_params)   # 将随机传过来的参数拆包，
		  
			    注:1.这里先根据房屋订单冲突的实际,查询到对应的订单对象,并将这些订单对象全部装到列表中,
			    	然后用列表生成器遍历,order_obj.house_id (订单对象.house_id,是利用Order()类中的外键取到对应房屋的id),这样
			    	返回的这个列表就是所有冲突的房屋的id,那么排除(notin_)这些房屋id,剩下的就是没有冲突的可以预定的房屋id
			    	2.创建查询对象（查询：对象.query.filter(条件).all(), 只有加了最后一个查询方法（如all(),get(),first()）才算是对数据库进行了操作）
			    	3.对于数据库查询操作都要进行 try...except...,并且用current_app.logger.error(e),将其记录在log日志中	


			8.补充排序条件
			    # 补充排序条件
			    if sort_key == "booking":
			        # 倒叙
			        query = query.order_by(House.order_count.desc())  # desc()是倒叙
			    elif sort_key == "price-inc":
			        query = query.order_by(House.price)
			    elif sort_key == "price-des":

			        query = query.order_by(House.price.desc())
			    else:
			        # new
			        query = query.order_by(House.create_time.desc())

			    注:sort_key 作为一个筛选条件(排序查询-->最新上线,入住最多,价格高低)
			    	在客户筛选的时候,可能会传过来,也可能不传,所以在前面校验参数的时候,没有校验
			    	那么在这里,判断的时候else就作为 没传的情况来处理,其他情况分别处理!    


			9.分页处理
			    # query.paginate(页数,per_page=每页容量，error—out=False 关闭自动错误输出)
			10.获取页面数据
			    # 获取页面数据
    			house_obj_list = page_obj.items

			11.获取总页数
			    # 获取总页数
    			total_page = page_obj.pages

			12.遍历结果对象,转换格式为字典
			13.返回数据    
			   return jsonify(errcode=RET.OK,errmsg="查询成功",data={"houses":house_dict_list,"total_page":total_page,"current_page":page}) # 房屋列表,总页数,当前页数返回

		
        测试:
        	添加发布房屋测试数据,添加房子!7-8组
        	postman以get方式访问:127.0.0.1:5000/api/v1.0/houses?p=1&aid=1&sk=price-inc


		------------------------------------------------------------------	   

		2.2前端:

		2.2.1my.html -----my.js (个人信息,我的订单,实名认证,我的房源,客户订单,退出)	    

			注:1.实名认证:如果没有实名认证,可以实名认证,并且实名之后,信息变灰
				2.我的房源:点开之后,内部有发布房源按钮-->进入发布新房源页面(参数有:
						房屋标题,价格,所在城区,详细地址,房间数量,面积,户型描述,人数,床,押金,最少天数,最多天数 非必选(配套设施))

		2.2.2myhouse.html ------myhouse.js

            <script id="houses-list-tmpl" type="text/html">
                <li>
                    <div class="new-house">
                        <a href="/newhouse.html">发布新房源</a>
                    </div>
                </li>
                {{each houses as house}}
                <li>
                    <a href="/detail.html?id={{house.house_id}}">
                        <div class="house-title">
                            <h3>房屋ID:{{house.house_id}} —— {{house.title}}</h3>
                        </div>
                        <div class="house-content">
                            <img src="{{house.img_url}}">
                            <div class="house-text">
                                <ul>
                                    <li>位于：{{house.area_name}}</li>
                                    <li>价格：￥{{(house.price/100.0).toFixed(0)}}/晚</li>
                                    <li>发布时间：{{house.ctime}}</li>
                                </ul>
                            </div>
                        </div>
                    </a>
                </li>
                {{/each}}
            </script>


        2.23发布新房源newhouse.html------newhouse.js
            当前端需要传递到后端并以表单的方式提交的时候的参数过多时,用传统的js方法
            不方便,需要用jQuery封装的方法来拿

            --------------------------------------------------------
            newhouse.js 定义好方法之后:
            	1.在浏览器页面Console输入:$("#form-house-info").serializeArray() -->查看列表数组
            		大列表包含的键值对数据俨然呈现:
					[ {name:"price",value:""} ,{} ,{} ,{} ... ]

				2.data={}

				3.$("#form-house-info").serializeArray().map(function(x){data[x.name]=x.value} )
				
				4.data
				 结果如下:Object {title: "", price: "200", area_id: "3", address: "", room_count: "1"…}
			
				5.在前端console输入:	$(":checkbox")-->查看所有复选框	$(":checked")-->查看已经勾选的 
				
				6.facility = []
				
				7.$(":checked[name=facility]").each(function(index,x){facility[index] = x.value})
					结果如下:
					       <input type=​"checkbox" name=​"facility" value=​"3">​, <input type=​"checkbox" name=​"facility" value=​"4">​, <input type=​"checkbox" name=​"facility" value=​"5">​]


			注: 1.map()方法:
					可以遍历数组中的元素,并将其取出执行回调函数
				2.设置空字典是用来装数据的,然后方便以键取值,map()函数,将元素取出来执行回调耗时,那么我们回调函数
				  就可以定义成 "给键赋值",这样一来就将表单形式的数据一次性全部搞定,不用再一个一个处理了
				3.这些方法都是在前端页面,js代码中实现的! 浏览器页面console只是为了验证! 
				4.each()方法:
					可以接受两个参数,这里接受的是 index下标 和 x键(即被遍历出来的内部元素)
				5.在提交上传房屋图片的时候,后端接收的数据都是json格式的,前端的页面并不能将多媒体格式 form-data 
					转换为能显示的格式,这个时候要在newhouse.html引入扩展:    <script src="/static/js/jquery.form.min.js"></script>
					添加回调函数来异步提交表单,在newhouse.js文件中再添加处理图片的函数
					其中:ajaxSubmit()函数是form.js扩展提供的


					遍历设置值:
					用each()方法遍历,可以接受两个参数(index ,值)


		测试:
			1.发布新房源:	填写房屋标题-->价格-->城区-->地址-->...>勾选设施等数据--发布房源信息
			2.上传房屋图片
			3.返回查看
			4.查看数据库:
			 	select * from ih_house_info \G;
			  	select * from ih_house_info;
				select * from ih_house_image;
				select * from ih_house_facility;



========================================================================
关于append()中 "=="的使用说明:
	1.查询条件直接查询:
		House.query.filter(House.area_id == area_id) 

	2.1把查询条件先追加到列表中
		list = []
		list.append(House.area_id == area_id)
	2.2然后再拿出来查询;

	注:这两种查询方式是一样的,因为"==" 实际上是封装了"__eq__()"这个魔法方法,它能返回运算之后的对象

延伸:
	== -->  __eq__
	>  -->  __gt__
	<  -->  __lt__
	>= --> __ge__
	<= --> __le__	


========================================================================
	BUG:1.'自定义装饰器的错误!
			AssertionError: View function mapping is overwriting an existing endpoint function: api_v1_0.wrapper

      	 装饰器要用:    @functools.wraps(view_func),不然返回参数,会报重写的错误

      	2. newhouse.js:67 Uncaught TypeError: $(...).sumbit is not a function
      		submit!!!!!!写错了,擦!保错!




========================================================================


疑问:
1.这个怎么理解?
            "image_url":constants.QINIU_URL_DOMIAN + self.index_image_url if self.index_image_url else "",
            ""
    答:这个是python中的三目运算写法  :self.index_image_url if self.index_image_url else ""      
    	如果有值,就返回:self.index_image_url,如果没值就返回"" 空! 

========================================================================
小结:

一.注意点
	情景一:   
	#判断城区id
    try:
        area = Area.query.get(area_id)
    except  Exception as e:
        current_app.logger.error(e)
        return jsonify(errcode=RET.DBERR,errmsg="数据库异常")

    情景二:
    # 保存用户的姓名和身份证号
    try:    # 在这里判断如果真实姓名和 身份证时空的时候 才能设置更新
        User.query.filter_by(id=user_id,real_name=None,id_card=None)\
            .update({"real_name":real_name,"id_card":id_card})
        db.session.commit()
    except Exception as e:
        current_app.logger.error(e)
        db.session.rollback()
        return jsonify(errcode=RET.DBERR,errmsg="保存用户实名信息失败")



    1.在进行数据库操作的时候,如果是查询操作,对数据库没有造成影响的,处理异常情况直接 return ...    
    2.对于数据库造成影响的操作,比如:改,删,增,处理异常需要进行回滚操作:
    	db.session.rollback()

    3.后端代码中,只要涉及到数据增删查改的操作,都要 try...except 进行捕获异常处理	



二.对于表里,多对多的情况
	要先创建对象  house = House()  , facility = Facility()
	查询设施数据-->返回的是设施对象列表:
	            facility_obj_list = Facility.query.filter(Facility.id.in_(facility_id_list)).all()
	保存房屋的设施信息:
		house.facilities = facility_obj_list



三.对于获取对象,为什么有的要加"",有的不需要呢?BUG'
	NoneType' object has no attribute 'houses'

	情景一:
    # 获取参数， 图片 和 house_id
    image_file = request.files.get("house_image")
    house_id = request.form.get("house_id")  # request.form也支持多媒体表单的文本数据提取

    情景二:
    """获取房东发布的房源信息条目"""
    user_id = g.user_id
    try:
        user = User.query.get(user_id)  -->这里不需要加哎!因为上面有现成的

    注:情景一之所以要加"",是因为提交的表单数据里含有这些json字符串转换成的字典数据,
    	这里直接使以键取值!!



四:myhouse.html
            {# 用art-template 来处理大量模板数据 #}
            <script id="houses-list-tmpl" type="text/html">
                
                <li>
                    <div class="new-house">
                        <a href="/newhouse.html">发布新房源</a>
                    </div>
                </li>

                {{ each houses as house }}
                <li>
                    <a href="/detail.html?id={{house.house_id}}&f=my">
                        <div class="house-title">
                            <h3>房屋ID:{{ house.house_id }} —— {{ house.title }}</h3>
                        </div>
                        <div class="house-content">
                            <img src="{{ house.img_url }}">
                            <div class="house-text">
                                <ul>
                                    <li>位于：{{ house.area_name }}</li>
                                    <li>价格：￥{{ (house.price/100.0).toFixed(0) }}/晚</li>
                                    <li>发布时间：{{ house.ctime }}</li>
                                </ul>
                            </div> 
                        </div>
                    </a>
                </li>
                {{ /each }}
            </script>



五.关于前端的用户验证
	
	    $("#form-house-image").submit(function (e) {
        e.preventDefault();

        $("#form-house-image").ajaxSubmit({   // ajaxSubmit()函数是form扩展提供的方法
            url:"/api/v1.0/houses/images",
            type:"post",
            dataType:"json",
            headers:{
                "X-CSRFToken":getCookie("csrf_token")
            },
            success:function (resp) {
                if (resp.errcode == "4101"){
                    location.href = "/login.html";
                } else if(resp.errcode == "0") {
                    $(".house-image-cons").append('<img src="' + resp.data.image_url + '">'); //拼接路径,展示图片

                } else {
                    alert(resp.errmsg);
                }
            }
        })
    })    
});

	注:本次项目是采用前后端分离的模式进行开发的,这也就意味着,除了传递和接收参数,前端和后端
		高度不重叠,那么,像登录验证这样的也要分别进行,不管后端验证登录了多少遍,前端还是得每次都要
		验证一遍用户是否登录,没有登录就返回"/login.html",


















































=============================================================
想一想:
	1.在保存房屋图片的时候,可以业务细化,上传多张房屋图片,然后将某一张作为展示房屋的主图片

	2.在解决订单并发问题的时候,flask可不可以用悲观锁,乐观锁来进行处理,老师讲的是消息队列的方法



***************************************************************
小结:
	1.flask中怎么设置访问视图函数的路由?
	答:用装饰器,前端在发起请求的时候,如发起ajax请求后面都会跟上请求路径:
		$.ajax({
			"/api/v1.0/user",function (e) {

			}
			})

		这个路径会让flask自动会去找装饰器路径为'/user'的这样一个视图函数

















