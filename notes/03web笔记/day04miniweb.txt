*** 如何将课件的html文件做成服务器的html文件进行访问？？
  要导入包import urllib ，

***pyQT开发:界面开发（跨平台）

*** 框架搭建模式;
    MVT（model保存模块 view显示模块  templates）  MVC

前言：服务器就好比是一个发动机 提供动力（负责接收浏览器的请求，分析请求，将获取的请求  信息转发给某一个核心模块，核心模块把数据交给服务器，服务器得到数据之后，将数据转发给   浏览器）----核心模块即框架：Django，flask
  
  动态数据给框架去处理，静态数据在服务器自己处理，
************************************************************************************
  WSGI协议：能够将服务器和框架的功能分离（解耦），高耦合意味着不易维护（*重点*）
**************************************************************************************
  一般动态网页：结尾：jsp，php



** GET /index.html HTTP/1.1 
   这个头信息的正则表达式可以表示为：(r"\w+ +(/[^ ]*)",request_start_line.decode().group)  

1.动态服务器：wsgi接口
  
  怎么可以不修改服务器和架构代码而确保可以在多个架构下运行web服务器呢？答案就是 Python Web Server Gateway Interface (或简称 WSGI，读作“wizgy”)

  在解析请求报文的时候：
    if file_name.endswith(".py")  如果请求是以 .py文件结尾那么就是动态页面

  它只要求Web开发者实现一个函数，就可以响应HTTP请求
   大致思路：服务器自己调用模块！！

   def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return 'Hello World!'

   上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：

    environ：一个包含所有HTTP请求信息的dict对象；*********是一个字典对象********
    start_response：一个发送HTTP响应的函数。

    application()函数必须由WSGI服务器来调用

   # 设置静态文件根目录
     HTML_ROOT_DIR = "./html"
   #
     WSGI_PYTHON_DIR = "./wsgipython"
   
    # 通过魔法方法导入模块
   if file_name.endswith(".py")
     m = __import__(file_name[1:-3])    # 这里切片/name.py为了得到name
       env = {}
       response_body = m.application(env,self.start_response)
       response = self.response_headers + "\r\n" + response_body     
    

********************************************************************************

课堂代码：
  1  以后通过 python3 xx.py 8888 my_app:app  来运行服务器
  
        
  2  通过模块名导入对应的模块，使用__import__ 内建函数
    在模块中通过函数的引用传参，而不是调用服务器
     具体方法如下;
      # 提取第三个参数
    param3 = sys.argv[2]
    # 导入的包名
    module_name = param3.split(":")[0]
    # 导入的方法名
    method_name = param3.split(":")[1]
    print(module_name, method_name)
    # 导入模块
    app_module = __import__(module_name)
    # 调用刚刚导入模块的方法 ，getattr 对象是object
    app_method = getattr(app_module, method_name)

  3.初始化app方法
     self.app = app
     self.headers =None
   4.run方法是用gevent实现的
   
  5. handle_with_request()中，
    if path.endswith(".py")
     print("访问的是动态资源")
  
     # 剩下的交给框架
        if path.endswith(".py"):
                print("访问的是动态资源")
                # 交给框架处理
                environ = {"PATH_INFO": path}
                response_body = self.app(environ, self.start_response)
                resp_headers = "HTTP/1.1 %s\r\n" % self.headers[0]
                # ******
                for key, value in self.headers[1]:
                    resp_headers += "%s:%s\r\n" % (key, value)
                resp_headers += "content-length:%d" % len(response_body.encode())
                resp_headers += "\r\n"
                resp = resp_headers + response_body
                new_socket.send(resp.encode())

  *这里environ={“path―info”：path}是将浏览器输入的地址以字典的形式，用传参的方法将environ 和start_response 传递到app框架里，进入框架之后，将路径取出来，判断，在app方法里通过start_response方法将定义号的 状态和 头信传递 给服务器，将路径对应的方法存放在字典中，以这个格式：“center.py”:center ,center就是对应方法的变量，将对应变量执行过程的返回值返回给服务器（即将center中读取的数据返回给服务器），当做动态返回信息的body，拼接头和body发送给浏览器


6. 创建my_app模块，并设置app方法
   app方法里有返回头信息和body信息的方法
  其中start_response(status,response_headers) 返回的是头信息，
  至于body信息：

     g_func_path_dict = {
    "/index.py": index,
    "/center.py": center}

   是以这种方式保存在字典中的 ，其中"/index.py"是获取的输入路径，inde是此路径的读取文件的方法，结果会返回读取的内容，content，最后返回的内容是通过调用func = g_func_path_dict.get(path) 返回给服务器的，需要注意的是def index（path）：方法里把html结尾的访问路径都替换成了“.py”,打开文件的路径需要加上前缀，f = open(g_templates_root + path)，因为这些静态文件都存放于template包中，所以在app这个模块最开始的地方需要把全局路径给指明，以便在导入包的时候sys.path会自动找到这个读取路径g_templates_root = "./templates"，

















   
7.# 需要将".html" 修改为静态资源对应的路径
                    f = open(g_static_root + path, "rb")


















****************************************************************************
app（method_ref） reference 引用

作业：通过动态导入的方式，导入类对象 --》实例化对象，并且调用对象方法


****************************************************************************

老师笔记：


# 服务器就好比是一个发动机 提供动力(负责接收浏览器的请求, 分析请求,将获取的请求信息转发给某一个核心模块,核心模块把数据搞定之后 把数据交给服务器,服务器得到数据之后 将数据转发给浏览器)




{
	{
		{
			{
				{

					不能够把主逻辑写的这么深, 代码可阅读性非常差
				}
			}
		}
	}
}

需要先判断错误的条件 然后return




框架搭建模式
M(model保存数据)V(view显示数据)T(template提供模板)框架搭建模式  MVT M(model)V(view)C(controller 控制器)



# 装饰器 @语法糖 内部是如何实现程序员不需要关心
# 学习装饰器内部是如何试实现 --> 先学习闭包 --> 和函数类似  -- 需要提前预习闭包和装饰器


今日作业: 通过动态导入的方式 导入类对象 --> 实例化对象,并且调用对象方法


# 了解web开发的流程 为了后面学生django 和flask 做的铺垫






注：函数当做参数使用来调用函数
   def test():
    print("哈哈哈哈")

# t = test
#
# t()

 
def demo(ref):
    ref()


demo(test)


mydict = {"name" : "张三"}
name = mydict.get("name")
print(name)
































































































































































































