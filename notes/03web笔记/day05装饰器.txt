面试题：装饰器，迭代器，生成器，
创业公司：短平快
期权：上市之后给股票


*通过引用调用函数

  def test():
    print('hahaha')
  
  work = test
  
  work(）

闭包：在函数里在定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数及用到的      一些变量称之为闭包


    # 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用 到的一些变量称之为闭包
***************重点**************闭包的执行过程********************************
 def func(num):
    def inner():
        # inner函数相对于func是内部函数
        # 在内部函数中使用 外部的变量 num
        print('11111',num)

    print('22222')
    #返回内部函数的引用
    return inner     # 执行过程是先执行右边的 func（2）
 test = func(2)  # 在这里func（2）相当于是调用函数，并且传值到函数中
 # 调用函数      # 然后return inner将函数当做变量返回给test，
               # 最后的test（） 相当于是调用inner（）函数
 test()




**注意点:

由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存

#课堂;闭包有一个特征，引用了外部变量的闭包能够让外部函数不被释放，如果func被释放，就会导致内部函数访问num1出错
   函数本身的特点：如果直接调用函数，外部没有引用，函数执行完就没了

***装饰器是一种闭包，可以理解为 把一个函数 当做参数传进闭包里的过程是给函数添加  装饰器
  
    4. 装饰器(decorator)功能

   引入日志
   函数执行时间统计
   执行函数前预备处理
   执行函数后清理功能
   权限校验等场景
   缓存

# 修改外部函数的变量
 # 在python3中如果希望能修改  外部变量此时需要使用到 nonlocal，此时就可修改外部变量
 # 在python2中如何解决呢？python2中没有 nonlocal关键字，只能够间接的来修改外部变量的值    比较麻烦



封闭：已实现的功能代码块
开放：对扩展开发

** 装饰器装饰 被装饰的函数，可以理解为把被装饰的函数当做参数传递进去装饰器里，进   行摩擦
   @yanzheng
   def order(count):
          print()
  
   把

 

在类外，创建对象，p(),如果调用对象，需要内建__call__方法

类装饰器：在用类装饰 函数时，要在类里新建call方法


多个装饰器装饰一个函数：
  最靠近的装饰器先装饰，执行时最外面的装饰器先执行




动态链接my_app代码：

  在my_app模块中，将路径设置一个装饰器，分别在路径函数上装饰，
 1.g_func_dict_path 字典  在import导入的时候已经完成了path和 函数引用的关系映射
 2.



*******************************************************
**** 一个路径对应一个可执行获取数据的函数 ---》路由****
*******************************************************






*****************************************************************************
课堂代码：
  

  1.闭包
 # 闭包是将函数做为返回值来使用
 # 函数只是引用了一段可以执行的代码

 # 闭包有一个特征, 引用了外部变量的闭包能够让外部函数不被释放, 如果func被释放, 就会导   致内部函数访问num1 出错


"""
什么是闭包?
1. 内部函数被外部函数当做返回值返回并且内部函数引用外部函数提供的变量, 此时将内部函数   和引用的外部变量构成的整体成为闭包

"""

  def func(num1):

      def inner():
          # 相对于func函数是内部函数
          # 在内部函数中使用 外部的变量 num1
          print("in inner", num1)

      print("in func")
      # 返回内部函数的引用
      return inner


  my_test = func(100)
  # 调用mytest 函数
  my_test()
********************************************************************************

 2.手动给order添加验证的功能
  

  # 手动给order添加验证的功能
  def yanzheng(func):
      # func 将被装饰的函数的引用传递到装饰函数中
      def inner():
          print('开始验证用户是否登录。。')
          print('开始验证是否有充足的货物。。')
          func()    *********重点******这里func（），就是order（）
       return inner

  def order():
      # 被装饰的函数
      print('开发订单的处理过程..')

  foo = yanzheng(order)
  foo()

  # 执行过程：先执行yanzheng(order)
  #return inner 将函数inner以变量的形式 返回出来，foo接收
  #foo = inner foo引用指向了inner
  #foo（）调用函数相当于调用inner（）
  #然后打印“登录”，“货物”，执行到func（），即执行order（）函数
  #打印 ‘开发订单’
  #返回func（），调用的地方
  # 再返回foo（）

  debug 用step into
------------------------------------------

  # 用@yanzheng的方法
  def yanzheng(func):
       # func 将被装饰的函数的引用传递到装饰函数中
      def inner():
          print('开始验证用户是否登录。。')
          print('开始验证是否有充足的货物。。')
          func()
      return inner

  @yanzheng
  def order():
      # 被装饰的函数
      print('开发订单的处理过程..')

  order()



***********************************************************************

3. 装饰有参数的函数
   # 装饰器函数  
 def yanzheng(func):
     # func 将被装饰的函数的引用传递到装饰函数中  *****
     def inner(count):
         print("开始验证用户是否登录....")
         print("验证货物是否卖光...")
         func(count)
         print("验证结束")

     return inner


 # 装饰器的能够让order 变成 inner 这就意味着 order 和 inner函数的定义是一样
 @yanzheng  # order = yanzheng(order)
 def order(count):
     # 被装饰的函数
     print("开发订单的处理过程....", count)

 order(1111)


 注：# 装饰器的能够让order 变成 inner 这就意味着 order 和 inner函数的定义是一样
   这句话意思是 order最终调用的是inner函数，所以两个函数的格式要是一样的以便之后方便传   值进去！！，def order（count）--------def inner（count）对应




******************************************************************************

4. 装饰有返回值的函数
  

   # 装饰器函数  装饰有返回值的函数
  def yanzheng(func):
      # func 将被装饰的函数的引用传递到装饰函数中
      def inner(count):
          print('111denglu')
          print("222kanhuo")
          ret = func(count)
          return ret
      return inner

  # 被装饰的函数
  @yanzheng
  def order(count):
      return "hello world %s" % count

  # 用res 来接收被装饰的函数order的返回的结果，也可以不接收
  res = order(100)
  print(res)

  注：1被装饰的函数有返回值，可以在外部接收 也可以不接收
     2.内部函数inner（count）要跟order（count） 一致
     3.如果order（参数），传进去的参数是不定长参数，那么在inner
       就需要用inner（*args,**kwargs）这种方式接收不定长参数而不能单纯的用（count)
       需要注意的是在inner 内部调用func的时候也需要加上func（*args，**kwargs）


********************************************************************************
5.类装饰器（把类变成装饰器，来装饰函数）

  class Person(object):
    def __init__(self, func_ref):
        self.func = func_ref


    def __call__(self, *args, **kwargs):
        self.func()


  @Person  # dadoudou = Person(dadoudou)  --> dadoudou 实际上是一个Person类型的  实例  对象
  def dadoudou():
      print("打豆豆")

  # 调用实例对象   'Person' object is not callable
  dadoudou()      # 实际上调用的是Person类型的对象的__call__方法



  注：因为类里不能像函数装饰器那样引用外部变量，以及调用，所以类类想要变成装饰器以及被    调用，（ p = Person() ，p()  # 'Person' object is not callable  函数和方法才能够被    调用），就只能在类里添加__call__方法，call就是调用的意思





******************************************************************************
6.有参数的装饰器  （在装饰函数时，装饰器传入参数）
  
  # 进行调试  日志的等级
  # notice：1 warning：2 error：3


  def log_level(level):
      def yanzheng(func):
          def inner(*args,**kwargs):   # 这里inner中的不定长是用来准备接收order里面的                                                    传参的  
              if level == 1:
                  print('输出提示信息:notice')
              elif level == 2:
                  print('输出警告信息:warning')
              else:
                  print('输出错误信息:error')
              print('开始验证登录...')
              print('开始查看库存...')
              ret = func(*args,**kwargs)
              return ret
          return inner
      return yanzheng

  @log_level(2)            # 这里输出日志函数也要传参！！！！！！！！！！
  def order(count):
      # 每次在调用order的时候 需要输出调用日志，日志的级别可以用手动设置
      return 'hello world %s' % count

  ret = order(50)

 注：
   1.输出日志函数（装饰器）要传参
   2.其实这里真正的装饰器是def yanzheng() 函数及内部的inner函数 
   3.每次在调用order的时候 需要输出调用日志，日志的级别可以用手动设置

 老师笔记：
    程序执行到 第7 行就有一个 log_level对象引用着对应的函数
    程序运行到25行, 发现了一个装饰器, 并且这个装饰器有参数
    此时会调用log_level(1) 此时函数会有一个返回值这个返回值是 yanzheng函数引用
    此时装饰器才开始执行 yanzheng函数才是真正的装饰器
    装饰器底层实现 是  order = yanzheng(order)
    在django项目中会大量的使用这种装饰器来传递路由参数
    """


********************************************************************************
7. 多个装饰器装饰一个函数
  
  # 多个装饰器装饰一个函数
  import time

  # 验证装饰器
  def yanzheng(func):
      def inner():
          print('开始验证登录')
          print('开始验证库存')
          func()
      return inner

  # 获取时间装饰器
  def gettime(func):
      def get_inner():
          # 获取func执行的时间
          # 起始时间
          start = time.time()
          func()
          # 结束时间
          end = time.time()
          # 时间差
          delta = end - start
          print(delta)
      return get_inner

  # 希望给login函数添加验证功能 并且还希望统计login执行消耗的时间
  @yanzheng
  @gettime
  def order():
      print('哈哈哈')
      for i in range(1):
          time.sleep(1)
 
  # 调用
  order()


  注：
    执行的顺序：
       先执行yanzheng装饰器中的inner函数--》再执行gettime中的getinner函数--》
       --》执行login--》装饰器中的函数执行完毕后再一层层的结束
    装饰的顺序： 
       先装饰gettime，将gettime装饰获取的返回值当做参数  交给验证装饰器来进一步装饰

***********************************************************************************


课堂老师笔记：
   什么是闭包？
     内部函数被外部函数当做返回值返回并且内部函数引用外部函数提供的变量，此时将内部函     数和引用的外部变量构成的整体称为闭包！！！
   
  闭包的特点：
     1.自动执行（在import阶段就已经开始自动执行）
     2.闭包有一个特征，引用了外部变量的闭包能够让外部函数不被释放，如果func被释放，就       会导致内部函数访问num1 出错
   
  开放和封闭原则：
     开放：如果需要对于已经定义好的函数增加功能，应该通过动态的扩展的方式扩展功能，而             不要直接修改已经封装好的底层代码  
     封闭：一旦底层的基本业务已经实已经现完毕，在没有特别重大的变动的需求下，就不要修           改底层已经封装好的代码
   miniweb项目:
      1.g_func_dict_path 字典在import导入的时候已经完成了path和函数引用的关系映射
      2.字典中保存的函数的引用 实际上就是定义的index 或者center
      3.按照g_func_dict_path[path] 获取的就是index函数，center函数，这就是路由     
  
   路由：
     # 让文件路径和被装饰的函数一一对应
     # 一个路径对应 一个可以执行获取数据的函数---》路由

总结：
  1 在闭包中的内部函数里，始终有外部变量在里面
  2 # func 将被装饰的函数的引用传递到装饰函数中，然后在inner类被调用func(),
     所以这就是装饰器的原理



注意：

 1. 在用装饰器 装饰miniweb中my_app 中打开动态路径的 函数时，如果在windows中报错  ，那么就在path 后面加上encoding=utf-8 

  2.在miniweb中装饰器的作用是
   # 装饰器完成对应的关键部分:装饰函数 将文件路径作为key 将函数引用作为value 存储到字典中




























































