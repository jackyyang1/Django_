

day01 数据结构


1.数据结构与算法

	数据结构就相当于一个整理衣服的箱子,目的是为了方便的使用数据
	
	数据结构和算法的作用:
		1.没有数据结构和算法,有时候面对问题可能会没有任何思路,不知如何下手取解决,
		2.大部分时间解决了问题,可是对程序运行的效果和开销没有意识,性能地下
		3.有时会借助别人开发的利器暂时解决了问题,可是遇到性能瓶颈的时候,又不知该如何进行针对性的优化


	程序 = 数据结构 + 算法	


2.算法概念:

	冒泡排序,快速排序
	栈:先入后出

	2.1引入概念
		求a,b,c,组合的-->枚举算法


	2.2算法的概念和五大特性
	
		算法是独立存在的一种解决问题的方法和思想

		算法的特性:
			1.输入
			2.输出
			3.有穷性
			4.确定性
			5.可行性

	2.4衡量算法效率:依靠运行时间不靠谱,依赖硬件		
	分析时间: 总的基本步骤  1000  1000
	时间频度: 1000*1000*1000=1000^3*10   1000^2*10
	T(n)=n^3*10   n^2*1000	
	时间复杂度: 比较的是函数的增长率
	渐进函数-->g(n)=n^3  g(n)=n^2
	表示算法的效率-->大O表示法 T(n)=O(n^3)  T(n)=O(n^2)  ---->去除系数,只保留最高项指数


	最坏时间复杂度:
		算法完成工作最多需要多少基本操作，即最坏时间复杂度


	2.6时间复杂度的几条基本计算规则:
		基本操作，即只有常数项，认为其时间复杂度为O(1)
		顺序结构，时间复杂度按加法进行计算
		循环结构，时间复杂度按乘法进行计算
		分支结构，时间复杂度取最大值
		判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
		在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度

	计算时间复杂度:
		1.计算时间频度 T(n)=n*n*(3+5+(if 1 + else 0))
		2.渐进函数:g(n) = n^2
		3.大O表示法: T(n) = O(n^2)

		T(n) = 1000 = O(1) 这种是最优的时间复杂度	,规模是1000

	log2n -->log以2为底	n的对数
	log28 = 3 -->log8=3 (2通常省略)


	常见时间复杂度:
		执行次数函数举例	阶	非正式术语
		12	O(1)	常数阶
		2n+3	O(n)	线性阶
		3n2+2n+1	O(n2)	平方阶
		5log2n+20	O(logn)	对数阶
		2n+3nlog2n+19	O(nlogn)	nlogn阶
		6n3+2n2+3n+4	O(n3)	立方阶
		2n	O(2n)	指数阶
		注意，经常将log2n（以2为底的对数）简写成logn


	所消耗的时间从小到大:
	O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)


	2.7python中timeit 模块

		# 1.测试打印字符串
		# timer = Timer('print("a")')
		# timer = Timer('print(a)','a=1')  # 给 'a'变量赋值
		# print("time:",timer.timeit(number=5)) # number指定次数


		# 3.测试
		def t1():
		    li = []
		    for i in range(10000):
		        li = li + [i]   # "+"--->效率最低


		def t2():
		    li = []
		    for i in range(10000):
		        li.append(i)


		def t3():
		    li = []
		    for i in range(10000):
		        li.insert(0,i)


		def t4():
		    li = [i for i in range(10000)]


		def t5():
		    li = list(range(10000))


		timer = Timer('t1()','from __main__ import t1')
		print('time:',timer.timeit(number=5))
		...

		结构如下:
		# time: 0.660479883551756
		# time: 0.004613641059853957
		# time: 0.09620273785957234
		# time: 0.0018431291516245452
		# time: 0.0013142036250440858


3.数据结构:
	我们如何用python中的类型来保存一个班的学生信息,如果想要快速的通过学生的姓名获取其信息呢?
	1.stus = [{'name':'zs'},{'name':'ls'},...]

	  for stu in stus:
		  if stu[name]='zs'	
	时间复杂度:O(n)		

	2.stus = {{'name':'zs'},{'name':'ls'},...}	
	  stus['zs']
	时间复杂度:O(1)


4.顺序表
	内存存储的时候 ->申请内存-->返回内存首地址(如果存储占用了多个格子)

	1.同一种数据类型存储: (即元素都占相同的字节)
		直接存储到连续存储空间!
		[1,2,3]

		-------
		|	1  |  0x51 + 4*0  ---->'1'占4个字节
		|------
		|	2  |  0x51 + 4*1  
		|------
		|	3  |  0x51 + 4*2
		--------
	
	2.对于相同类型的数据(如:对象加其他类型数据)的存储
		[1,2,obj] 	
		把元素随便存储(元素外置),然后存储它返回的地址
		元素外置-->保证python能存储任何数据


	3.顺序表的结构:
		表头 + 元素存储区

		元素个数:方便统计长度
		容量:方便判断容量已满	

		
		容量:4*6=24个字节
		--------
		|	4  |   表头占两个
		|------
		|	3  |  
		--------
		--------
		|	1  |  0x51 + 8 + 4*0  
		|-------
		|	2  |  0x51 + 8 + 4*1  
		|-------
		|	3  |  0x51 + 8 + 4*2
		|-------
		|	   |   
		|-------
	

		一体式结构:
			如果空间不足,它会重新申请一块内存,同时返回的内存首当做
			就会改变;

		分离式结构:(python中使用的是分离式顺序表)
			空间不足,扩容,重新申请内存,表头不会重新申请,只扩容元素存储区	
			表头不变,即内存id永远不变,查找内容的时候,表头会指向对应元素内存


	4.python中顺序表的特点: (list 和 tuple 使用的都是顺序表的技术)

		基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；

			为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。

		允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。

			为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。		


	5.操作
		5.1增加元素
		a. 尾端加入元素，时间复杂度为O(1)

		b. 非保序的加入元素（不常见），时间复杂度为O(1)

		c. 保序的元素加入，时间复杂度为O(n)


		5.2删除元素	
		a. 删除表尾元素，时间复杂度为O(1)

		b. 非保序的元素删除（不常见），时间复杂度为O(1)

		c. 保序的元素删除，时间复杂度为O(n)
		
	6.list内置操作的时间复杂度
		append()     O(1)		
		pop()        O(1)
		pop(i)       O(n)
		

		 


5.链表



6.栈


7.队列























































































































































