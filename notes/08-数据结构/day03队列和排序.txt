





队列:
	只允许在一端插入,在另一端进行删除操作的线性表。


	注:栈是先进后出,队列是先进先出


	实现队列          插入(时间复杂度)    删除(时间复杂度)           时间复杂度
	队列             insert(0)->O(n)     pop()->O(1)
	栈               append() ->O(1)     pop() ->O(n)
	链表             insert(o) 头部 O(1)  pop()



1.queue代码实现

	



2.双端队列:
	是一种具有队列和栈的性质的数据结构.

	双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。

	双端队列的方法:
	Deque() 创建一个空的双端队列
	add_front(item) 从队头加入一个item元素
	add_rear(item) 从队尾加入一个item元素
	remove_front() 从队头删除一个item元素
	remove_rear() 从队尾删除一个item元素
	is_empty() 判断双端队列是否为空
	size() 返回队列的大小




3.排序与搜索
	排序算法(sorting algorithm) 是一种能将一串数据按照特定顺序进行排序的一种算法


	3.1冒泡排序(Bubble Sort)
		它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来

		特点:只要出现前面大于后面就交换数据

		运作如下:
		1.比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
		2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
		3.针对所有的元素重复以上的步骤，除了最后一个。
		4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


		最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）
		最坏时间复杂度：O(n2)
		稳定性：稳定


	3.2选择排序(selection sort)
		首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

		特点: 遍历完一次才进行一次数据交换

		时间复杂度:
		最优时间复杂度：O(n2)
		最坏时间复杂度：O(n2)
		稳定性：不稳定（考虑升序每次选择最大的情况）


	3.3插入排序(insert sort)	
		它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

		特点: 将两两比较,小的与大的交换

		最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）
		最坏时间复杂度：O(n2)
		稳定性：稳定

		 注:小的 下标大,交换下标


	3.4希尔排序(shell sort)
		希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

		理解:

		步长3
		步长2
		步长1

		不再是相邻的数据进行比较,而是按照比较大的步长先比较
		比较完一次之后,缩小步长,再进行比较!
		希尔排序是优化版的插入排序!

		从步长的位置开始,直接遍历后面的数据!前面的不需要遍历

	========================================
	递归:
		1.正递归
		def cur(n):
			if n = 0:
				return
			print('*'*n)
			cur(n-1)

		结果如下:
		*****
		****
		***
		**
		*

		2.反向递归
		def cur(n):
		if n = 0:
			return
		cur(n-1)
		print('*'*n)

		结果如下:
		*
		**
		***
		****
		*****
		注: 反向递归是先将递归函数执行完,然后再调用打印


	========================================
	

	3.5快排(quick sort)  最重要的排序!!!


		步骤为：

		1.从数列中挑出一个元素，称为"基准"（pivot），
		2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
		3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。



		def quick_sort(alist, start, end):
		    """快速排序"""

		    # 递归的退出条件
		    if start >= end:
		        return

		    # 设定起始元素为要寻找位置的基准元素
		    mid = alist[start]

		    # low为序列左边的由左向右移动的游标
		    low = start

		    # high为序列右边的由右向左移动的游标
		    high = end

		    while low < high:
		        # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动
		        while low < high and alist[high] >= mid:
		            high -= 1
		        # 将high指向的元素放到low的位置上
		        alist[low] = alist[high]

		        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动
		        while low < high and alist[low] < mid:
		            low += 1
		        # 将low指向的元素放到high的位置上
		        alist[high] = alist[low]

		    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置
		    # 将基准元素放到该位置
		    alist[low] = mid

		    # 对基准元素左边的子序列进行快速排序
		    quick_sort(alist, start, low-1)

		    # 对基准元素右边的子序列进行快速排序
		    quick_sort(alist, low+1, end)


		alist = [54,26,93,17,77,31,44,55,20]
		quick_sort(alist,0,len(alist)-1)
		print(alist)
		时间复杂度
		最优时间复杂度：O(nlogn)
		最坏时间复杂度：O(n2)
		稳定性：不稳定


