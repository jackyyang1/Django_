1.如何理解引用传参，实际传递的是什么？
答;变量存储的实际上是数据的引用，可以理解为数据在内存中的地址，传递时，实际上传递的也是数据的引用


2，什么是注释？有什么作用？
* 注释是编程中，对某些代码的标注说明；作用是增强代码的可读性

3，在python中的中文注释是什么？
  *  #coding=utf-8

4，什么是变量？怎么定义变量？变量的类型有哪些？分别是？
 * 变量是用来存储数据的，定义变量名：变量名 = 值（给变量名   赋值）
 变量的类型有 ：
 数字：整型-int，
       浮点型-float，
       长整型--long，
       复数--complex。
 布尔类型 ： True    值
   	     False    值
 字符串 ：  str
 元组：   tuple
 列表：   list
 字典： dictionary


5，如何知道一个变量的类型？
 type（变量名）

6，什么是标识符？命名规则是？
* 标识符是 开发人员在程序中自己定义的一些符号和名称
 *标识符规则：标识符由 字母，数字，下划线组成，且数字不能开头
命名规则：大驼峰法：NewName  小驼峰法：newName 
            下划线法：new_name

7，什么是关键字？怎么查看python中的关键字？
*关键字：python中具有特殊功能的标识符，我们在定义标识符时不能与关键字相同
*查看关键字：import keyword
             keyword.kwlist -->共33个

8，常用的格式化输出符号有哪些？python2中与python3中输出的区别是？换行输出怎么操作？
* 有 %s--字符串，%d--十进制整数，%f--浮点实数，
* python2中输出 print 'hi'
  python3中 输出 print（'hi'）
* 输出时，如果有  \n ，那么\n之后的内容会显示在另外一行

 * \n换行    \t空格


9.python2中raw_input 和input的区别？

* 在python2中input 与raw_input类似，但其接受的输入必须是表达式,如"abc"+"def" ,a = input(1+2)
python2中的raw_input与python3中的input功能一样


10，常用的数据类型转换有：
   int(),str(),float(),tuple(),list()
   chr()  将整数转换为字符
   ord() 将字符转换为整数

11，判断语句的应用场景？
 *输入账号密码，进站安检

12，if语句的格式？if-else？if-elif？if嵌套？
    if 要判断的条件：
        条件成立执行的代码
    
if-else：
     if 要判断的条件：
        条件成立代码
      else：
         条件不满足执行的代码
if-elif：
      if 条件：
        条件成立执行的代码
      elif 条件：
         条件成立执行的代码
if 嵌套：
        if 条件1:

        满足条件1 做的事情1
        ...(省略)...

        if 条件2:
            满足条件2 做的事情1
            ...(省略)...
         

13，比较运算符？逻辑运算符？
    比较(即关系)运算符：==  ！=   <>   <=  >=  >   < 
    逻辑运算符: and   or     not 

14，while循环格式？break 和 continue 的作用？for循环格式？
* while 条件：
      条件满足执行的代码

*  break 立即终止并跳出循环，continue 立即结束当前循环，并    开始下一次的循环的条件判断

*  for 临时变量 in  字符串or元组or列表：
               代码


15，while嵌套，打印三角形
   while 条件1：
       满足条件1，执行的代码
       
        while 条件2：
            满足条件2，执行的代码
  打印三角形：
    *
    * *
    * * *
    * * * *
    * * * * *
    i = 1
    while i<=5:

        j = 1
        while j<=i:
            print("* ",end='')
            j+=1

        print("\n")
        i+=1

16，什么是字符串？定义字符串的四个方式是？
* 双引号或者单引号中间的数据，就是字符串
* '',"",'''''',""""""

17,切片的语法？反转字符串怎么做到？
 *切片 = [起始：结束：步长]

面试题：反取[::-1]

18,字符串的常见操作？
* find   
  检测 str 是否包含在 mystr中，如果是返回开始的索引值，否  则返回-1
*index   
  跟find()方法一样，只不过如果str不存在 mystr中会报一个异常
*count
  返回 str在start和end之间 在 mystr里面出现的次数
*split
   以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅   分隔 maxsplit 个子字符串
*isalpha
   如果 mystr 所有字符都是字母 则返回 True,否则返回 False
*isdigit
   如果 mystr 只包含数字则返回 True 否则返回 False
*isalnum
   如果 mystr 所有字符都是字母或数字则返回 True,否则返回    False
  
面试题  \t是空格的意思   用split切分

19，代码执行的三种格式？
 *顺序执行，选择执行，循环执行

20，什么是列表？
 * 列表是元素以[]包裹，以逗号分隔的，有序的序列
 列表里的元素可以是['字符串'，数字，列表[],字典{}]
  列表可以切片
   可以用for循环，while循环遍历列表
   其中 while循环遍历如下：
     namesList = ['xiaoWang','xiaoZhang','xiaoHua']

    length = len(namesList)

    i = 0

    while i<length:
        print(namesList[i])
        i+=1

21，列表的常见操作： 增，删，查，改
  
   增（append，extend，insert）
   append 加在最后
   extend 将列表拆分成单个元素加在列表中
   insert 将制定元素在在指定位置 insert（1，3)

   改
  修改元素的时候，要通过下标来确定要修改的是哪个元素，然后 才能进行修改

   查 （in，not in， index，count）

    a = ['a', 'b', 'c', 'a', 'b']
    a.index('a', 1, 3) #在指定长度里面查找，注意是左闭右开区 间

   删（del，pop，remove）

   del：根据下标进行删除      del.list[0]
   pop：删除最后一个元素       list.pop()
   remove：根据元素的值进行删除  list.remove('hello')
  
 8个老师分三个教室： rooms[index].append(name)


22, 什么是元组？
   * 元素以小括号包围，以逗号分隔的不可修改的序列
    元组不可修改元素  也不能删除元素
     count ，index

23 ，什么是字典？dictionary
 *大括号，逗号，键值对形式， 冒号，
  字典中修改元素是通过键来修改
 *给不存在的键赋值就是给字典添加元素
   dic['name'] = 'huanghuahua'
  *访问不存在的键 会报错
  *在我们不确定字典中是否存在某个键而又想获取其值时，可以 使用get方法，还可以设置默认值
   age = info.get('age')
 >>> age #'age'键不存在，所以age为None
 >>> type(age)
 <type 'NoneType'>

* 删除元素 del  clear()
  del dic['name']  删除指定元素
  del dic   删除整个字典
  dic.clear()  清空字典

24，字典常见操作：
   len() , keys, values, items ,has_key

    dic.keys()

25,字典的遍历;
 1,遍历字典的键key:  for key in dict.keys():
 2,遍历字典的值value：
 3，遍历字典的元素item：

*   列表枚举
  enumerate：
 b = []
 for x,data in enumerate(b):
    

26,公共方法：
  1，字符串，列表，元组：+   *
  2，字符串，元组，列表，字典：in，not in

27，什么是函数？函数的格式？调用函数？函数的文档说明？
  * 函数可以减少重复代码的
* 定义函数： def 函数名（）：
                   代码
*调用函数： 函数名（）
* 文档说明是解释函数的作用  
*定义时小括号中的参数，用来接收参数用的，称为 “形参”
 调用时小括号中的参数，用来传递给函数用的，称为 “实参”

27，什么是函数的返回值？怎样保存返回值？
* 返回值是，函数执行完之后，返回给调用者的结果
* 如果想要将结果返回给调用者，需要在函数中使用return

* 保存返回值: res = add（a，b）
* 函数的四种类型：无参无返，
                 无参有返
                 有参无返
                 有参有返

28，函数嵌套
29，局部变量，全局变量
*  局部变量，就是在函数内部定义的变量，只能在函数内部使用
 局部变量的作用，为了临时保存数据需要在函数中定义变量来进 行存储，这就是它的作用

*函数外定义的变量是全局变量
 全局变量能够在所有的函数中进行访问
 global  修改全局变量
  #不可变类型修改全局变量的时候需要对
  # 编译器用global命名，可变类型不需要 list.append()


30，缺省参数，不定长参数，命名参数
 * 定义函数是给形参赋值
* 数量不定的参数
* 在传参时，给实参赋值

31，引用传参：
   见第一条

32，递归函数，匿名函数

  *递归： 函数在内部调用函数本身，递归函数要有一个结束条件，不然会死循环
* lambda arg1，arg2...：expression
* 给字典排序：按name排序;
   stus.sort(key = lambda x:x['name'])
   print(stus)

33,拆包（解包）
  *将容器中的元素拆开来，传参进函数
  demo（num，*实参元组，**实参字典）

34，什么是文件？文件的作用？
* 文件是连续的字节序列
* 把一些存储存放起来，以便下一次执行的时候直接使用

35，文件的操作流程：
   打开（或者新建一个文件），读取/写入,关闭文件
   打开： file = open('test.txt'，'w')
         文件默认打开方式是 r模式
  
         访问模式：r  只读 ，w  只写 ，a 追加
                r+，w+，a+ 都是读写

  关闭：file.close()
  
   写入：f = open('test.txt','w')
         file.write('abc')
         file.close()   #关闭文件之后才会保持写入的数据
       *写入模式打开已存在的文件，会覆盖原内容
         写模式打开不存在的文件，会创建文件  
 
 读取文件的四种方式：1，file.read()  
                     2，file.read(5)
                     3,file.readline() #只读一行
                     4,file.readines()  

36，怎么样实现文件的复制？
 * 同时打开两个文件test1,test2,将test1文件中的内容读得到 test2文件中，然后关闭两个文件，即完成了文件之间的复制


37，如何获取当前I/O的位置呢？
* 使用tell（）来获取当前文件的读写位置

38 ，需要从文件的另一个位置进行操作的话，改怎么操作？
* 使用seek（）

* seek（offset，from）
  offset ：偏移量
  from ：方向
 seek（5，0） 表示从文件开头偏移5个字符
  seek（-5，2）从文件结尾向前偏移5个字符
  seek（3，1）表示从文件当前位置向后偏移3个字符    


39，使用os模块：
 * import.os
 * 1,文件重命名 
    os.rename('test.txt','text1.txt')
   
   2,删除文件 
    os.remove('文件名')
   
  3，创建文件夹
    os.mkdir('提莫')
  
   4，获取当前目录
     os.getcwd()

   5,改变当前目录
     os.chdir('../')
   
   6,获取目录列表
     os.listdir('./')
   
    7,删除文件夹
     os.rmdir('提莫')

  使用os模块创建一个名为“盖伦”的文件夹
 1，获取盖伦文件夹当前所在目录（mkdir）
 2，获取当前的目录列表   （getcwd）
 3，改变文件的操作路径    （ch
 4，将盖伦文件夹删除

 参考代码:
     import os
     os.mkdir("盖伦")

     os.getcwd()

     os.listdir("./")

     os.chdir("../")

     os.rmdir("盖伦")

    重命名：os.rename('盖伦'，'提莫')

40，面向对象：

* 对象是面向对象编程的核心，在使用对象的过程中，为了将具有  共同特征和行为的一组对象抽象定义，提出了另外一个新的概念  ――类
  拥有相同(或者类似)属性和行为的对象都可以抽像出一个类

* 类和对象的关系：类相当于是对象的模板

 * 定义一个类：
  class 类名（）：
        方法。。


 *类的三个组成部分是： 类的名称，类的属性，类的方法

 *类命名的规则：大驼峰命名法
 
 * 通过类创建对象： class 类名（）：
                         方法名
                      对象名 = 类名（）
 
* 为创建的对象添加属性：
      class  People（）：
         pass
    mayun = Penple（）
    mayun.company = "阿里巴巴"  # 对象名.属性名 = 属性值

*属性和全局变量的区别：
  不同对象的属性独立存在，互不干扰
   全局变量，一旦更改，会影响整个程序
    
41，__init__方法 和__str__方法，self：

  init方法的作用：当使用类创建对象的时候，系统会自动调用    init方法，因此用init来完成一些初始化值的设置

     class Human（）：
          def__init__(self):
                pass

  str 方法的作用: 当系统要打印对象时，会自动调用str方法返   回的值     注：str 必须有返回值，返回值必须是字符串类型


   用__init__方法给对象添加类：
    class People（）：
          def __init__(self,company):
               self.company = company
          def __str__(self):
               return '马云的公司是：self.company'
           

        mayun = People（'阿里巴巴'）
        print(mayun)      

  *self 是魔法方法的形参，代表对象自己
    某个对象调用其方法时，python解释器会把这个对象作为第一   个参数传递给self，所以开发者只需要传递后面的参数即可


42，隐藏数据：
  1，直接通过对象名修改
    对象名.属性名 = 数据
   2，通过间接方法修改
     对象名.方法名（）

  *扩展：1， # 私有属性，加_ _两个下划线，解释器会自动在属性名前加前缀:_                          类名,(_Person) 
         2，在类之外访问私有属性，实际上是新建了一个属性(详情见深度笔记)
         3，zs.set_age(10) # 私有属性可以通过方法来访问
     
 * dir（对象名）  可以查看对象的所有属性
 * log日志的使用  def 方法名():  #通过这种方式来决定是否使用此方法
                   #  方法     print('---执行了---')
                       pass
 * 正常工作时，在类里面要多用私有属性和私有方法（即加_ _前缀），这样可以     防止在类外不小 心调用类里的方法

43，保护对象的属性：
    有两种方法：1，将属性定义为私有属性  _ _属性名
                2，添加一个可以调用的方法，供调用
   
    __del__方法：当销毁对象时自动执行，一般用于释放资源
               当对象所有的引用都删除后，对象才会被销毁


44，继承：
    单继承：
     子类可以使用父类（基类）的功能（属性和方法）
     
     *子类不能使用父类的私有属性和私有方法

     *多继承：子类继承多个父类的属性
            如果父类有重复的方法，可以用如下方法：
            Ma.walk(luozi)   来调用指定父类的方法
            父类名.方法名（对象名） *这种方法仅适用于直接继承  （父类--                                  子类），如果是多层继承的话就不能适用了

     * 重写：  子类跟父类有同名的方法
            当重写了父类方法，调用时将执行子类的方法
      重写并使用父类方法：
           1，父类名.方法名（对象名）

           2，super().方法名()   # 参数里不需要传self                               （此方法仅限于python3中使用）
             在子类里： def eat(self):
                           super().eat()

           3.super(子类名，子类对象).方法名() # python2
                super(Cat,self).eat() 
  
45,面向对象的三个基本特征：
   封装，继承，多态
    
 *封装： 类里封装了函数和变量  --代码管理
 *继承： 子类可以使用父类的功能 -- 代码复用
 *多态： 父类变量的引用可以指向子类对象


46，* 实例对象：使用定义的类创建的对象

    * 实例方法：self代表了当前调用方法的实例对象，这种方法叫实例方法
        （m：在类里面凡是传参给self的都可以理解为实例对象，注意;这里self只是一个标识符，也可以写成其他的，当实例调用时，也同样叫做实例方法，但通常一般写作self）

    *  类对象：解释器根据class代码自动生成的对象，类对象被所有实例对象所共有 ？？？？？？？
     class People（object）：
          name = 'renzichao'  # 公有类属性
          _ _age = 18       # 私有类属性
 
     p = People（）
     print（p.name)
     print(People.name)
    在类外，实例对象和类对象都可以调用公有类属性

 *类方法：
 
   cls接收的是当前类的类对象，这种方法叫类方法，一般用来处理类属性

   类方法用途：可以对类属性进行修改
    语法糖（修饰器）
    @class method
     def getcountry（cls）：
          return cls.country
    @class methond
     def setcountry(cls):        #修改类属性
          cls.country = country

 *静态方法： 通过修饰器@staticmethod进行修饰的方法，不需要                 多定义参数 
  （m：静态方法一般用来代替函数，因为函数要传没有名字的数字，不好用self等这些形参来传递，如果在类外面写一个函数def 又太不和谐）

  *类属性，类方法，静态方法之只能通过 类对象  调用
    虽然实例对象也可以调用，但是不建议使用

47，__new__方法：
  *  作用：创建对象  （或者选择不创建）
     在创建对象时自动执行，init方法是在创建对象后执行 
  *new方法必须要有返回值，不然就无法创建对象（在我们定义类      时，如果没有创建new方法，python解释器会自动生成并执      行new方法，以保证能够创建对象，好比隐形的方法）
   new方法如下:
   class Person(object):
    
       def __new__(cls):
            obj = object.__new__(cls)  *这里实际上是手动调用了
            return obj                *object.__new__()方法 
       def __init__(self,name,age):
            self.name = name  
    *当我们不创建__new__方法时，类里解释器会自动调用new方法来创建对象
    *传递给init的值，在new中也会接收到 

48，什么是设计模式？

  * 大牛编写的代码模板，作用:按照模板套路编写代码，可以解  决复杂的问题
   *单例模式： 控制一个类只生成一个对象的设计模式，例如任         务管理器
    class Person（object）：
       instance = None
       def __new__(cls):
          if instance = None:
            cls.instance = object.__new__(cls)
            return cls.instance
       def __init__(self):
          print('init')
          self.name = name 
      #  单例创建时，只执行了一次__init__方法        
    
49，什么是异常？
   * 代码执行出现问题叫异常
  *捕获异常：try：
                可能出现异常的代码
             except：
                 出现异常对代码的修正

   *捕获多个异常;1,try:
                   except:
                   except:
                    ...
          2.try:
            except (异常类型1，异常类型2.)：
          3，try:
             except Exception:

     * 获取异常的信息描述：
            try：
            except 异常名 as 别名：
             print（别名）
            
     * try...except...else
       当没有出现异常时else才会执行
     *try...except..else..finally
        不管有没有异常finally都会执行
     
     * 异常的传递：在定义函数时如果出现异常，会传递给调用             者
50，抛出异常：
    你可以用raise语句来引发一个异常。
     异常/错误对象必须有一个名字，
     且它们应是Error或Exception类的子类

     *自己定义一个异常：
      class MyException(Exception):
           def __init__(self,age):
                self.age = age
           def __str__(self):
                return '年龄不能小于0'
   
      age = input('请输入年龄（不能小于0）：')
      if age < 0:
       raise MyException(age)     # raise抛出异常
       作用是:抛出异常，留给调用者处理

51，什么是模块？什么是包？
  *  模块是一个py文件
    模块的作用：让代码获得更好的划分和管理

   *导入模块的5种方法：
    1，import 模块名    # my_model.func1
    2，import 模块名 as 别名  # mm.func1
    3，from 模块名 import 功能名  # func1
    4，from 模块名 import 功能名 as 别名  # mm()

    5，from  模块名 import *  # 这种方法没办法使用别名 # 使用 * 来导入，只能导入被 __all__ 变量声明的功能
   
   * 测试模块： test.py中的测试代码，应该是单独执行       test.py文件时才应该执行的，不应该是其他的文件中引       用而执行
        可以根据__name__变量的结果能够判断出，是直接执行        的python脚本还是被引入执行的，从而能够有选择性的        执行测试代码
        即：在测试模块里加入if __name__=='__main__':
                                 func1()
                                 add(11,22)
          既可以达到测试功能，又不会在被导入时运行

   * 包是装模块的文件夹
   *导入包的4中方法：
     1，import 包名.模块名
     2，from 包名 import 模块名
     3，from 包名 import 模块名 as 别名
     4，from 包名.模块名 import 功能名 

52，模块中的__all__
    
   在包中（文件）|__init__.py  --__all__=['my_model','my_model2']
                 |my_model.py     # 要在init.py文件里用all声明
                 |my_model2.py      两个模块的名字才能调用模块功能

    *总结: __init__.py在包里的作用：

          1，__init__.py 可以初始化包的相关数据
          2，在python2，包里必须要有__init.py才能被导入
          3，提供__all__变量控制包里哪些模块可以被导入

    * 跨包之间不能导入模块
    *导入多层次嵌套的包：1,import 父包.子包.模块
                         2,
                        3,  
     * 安装模块：pip install 模块名
       卸载模块：pip uninstall 模块名
       搜索模块：pip search 模块名   

53，给程序传参数：
   import sys
   print(sys.argv)

54,列表推导式：
  1, a = [x for x in range(4)]
     a = [0,1,2,3]
  
   2, a = [x for x in range(1,10) if x%2 ==0]
      a = [2,4,6,8]
  
   3, a = [(x,y) for x in range(1,3) for y in range(1,3)]
      a = [(1,1),(1,2),(2,1),(2,2)]
         这里相当于是有两个for循环 ，如下
         for x in range(1,3):
            for y in range(1,3)
               a.append((x,y))
   4,a = [x**2 for x in range(5)]    #  x 的平方
     a = [0,1,4,9,16]   

55,集合
   a = {11，22，33}
   集合特点：1，元素不重复
             2，没有顺序，没有下标，不能获取元素
            3，可以添加和删除，不能修改和查看
    *使用set可以转换为集合，并去重复元素  b=[1,2,3,3]
                                         c = set(b)
      可以和list 相互转换                b = {1,2,3}
      可以和tuple相互转换                a = list(b)
      list也可以转tuple                  a = [1,2,3]
    *字符串可以转列表，但列表就不能转字符串，转完就不是原来的了
    



  *99乘法表 for循环，while循环 ，猜拳游戏

56，# 使用for循环99乘法表

  for i in range(1,10):
      for j in range(1,10):
          print('%d*%d=%-2d'%(i,j,j*i),end=' ')
          if i == j:
              break
      print()
   

 i = 0
while i <= 9:
    j = 0
    while j <= 9:
        j+=1
        print('%d*%d=%-2d'%(i,j,j*i),end=' ')
        if i == j:
            break
    print()
    i+=1


    






    