

订单模块


全选和全不选


$(this).find('checkbox').prop('checked')

找到用户选中商品的id: $('':checked)

根据更新结果操作:
	重新设置页面上购物车商品的数量

QueryDict对象可以一次性拿到所有的值:
	QueryDict.getlist()


1.购物车通用思路(重点)(默认异步请求,代码直接往下走,不会等待)
	1.获取删除的商品id(sku_id)
	2.发起ajax  post请求,访问/cart/delete,传递参数:商品id(sku_id)
	3.根据删除结果执行相应的操作
		删除成功:
		3.1移除页面上商品对应ul元素
		3.2重新设计购物车商品的小计
		3.3如果商品对应的checkbox被选中,更新页面上被选中的商品的总数目和总价格
		3.4重新设置页面上购物车商品的总件数
		更新失败,弹出错误信息

		更新购物车:hset()


	ajax请求的同步和异步""

	ajax请求默认是异步的请求:
		即ajax发起请求之后,代码直接往后走,而不会等待回调函数完成(获取total_count的函数)
		即获取不到total_count,解决方法为:设置ajax请求为同步亲请求




2.购物车记录删除js思路: (异步请求)(重点)
	1.获取删除的商品id(sku_id)
	2.发起ajax  post请求,访问/cart/delete,传递参数:商品id(sku_id)
	3.根据删除结果执行相应的操作
		删除成功:
		3.1移除页面上商品对应ul元素
		3.2重新设计购物车商品的小计
		3.3如果商品对应的checkbox被选中,更新页面上被选中的商品的总数目和总价格
		3.4重新设置页面上购物车商品的总件数
		删除失败,弹出错误信息




	商品订单页面要传递给付款页面的数据就只有一个商品id(sku_id)

	剩下的数据(数量,价格,用户地址)全部都是从redis查出来的,然后需要付的总金额
	用刚刚获取的数据来计算出来(total_pay),






3.订单模块:
	1.订单信息表(df_order_info)
	2.订单商品表(df_order_goods)

	订单创建流程: (最重要!!!!!!!!!!!!!!!!)
		接收参数
		进行校验
		组织订单信息
		todo:向df_order_info表中添加一条记录
		todo:遍历向df_order_goods中添加记录
		todo:


	用户每下一个订单,就要向订单里面添加记录



	时间格式化:
		datetime.now().strftime()


	列表拆包
		

	var csrf = csrfmiddlewaretoken






后天:
	mysql事务
	订单并发

	支付宝支付文档,使用流程

































-------------------------------------------------

1.
    if not all([]):
    	校验提交的的参数是否完整,通常用[],包起来然后判断,因为all()里参数要求是可迭代的


























































































































